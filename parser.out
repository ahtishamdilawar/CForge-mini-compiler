Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement
Rule 3     statement_list -> statement_list statement
Rule 4     statement -> declaration
Rule 5     statement -> assignment
Rule 6     statement -> function_declaration
Rule 7     statement -> function_call_statement
Rule 8     statement -> conditional
Rule 9     statement -> loop
Rule 10    statement -> return_statement
Rule 11    statement -> print_statement
Rule 12    statement -> read_statement
Rule 13    statement -> empty
Rule 14    empty -> <empty>
Rule 15    function_call_statement -> function_call SEMICOLON
Rule 16    declaration -> type IDENTIFIER SEMICOLON
Rule 17    declaration -> type IDENTIFIER EQUALS expression SEMICOLON
Rule 18    type -> INT_TYPE
Rule 19    type -> FLOAT_TYPE
Rule 20    type -> STRING_TYPE
Rule 21    type -> BOOL_TYPE
Rule 22    assignment -> IDENTIFIER EQUALS expression SEMICOLON
Rule 23    expression -> logical_expr
Rule 24    expression -> function_call
Rule 25    logical_expr -> comparison_expr
Rule 26    logical_expr -> logical_expr AND comparison_expr
Rule 27    logical_expr -> logical_expr OR comparison_expr
Rule 28    logical_expr -> NOT comparison_expr
Rule 29    comparison_expr -> arithmetic_expr
Rule 30    comparison_expr -> arithmetic_expr comparison_op arithmetic_expr
Rule 31    comparison_op -> LESS_THAN
Rule 32    comparison_op -> GREATER_THAN
Rule 33    comparison_op -> LESS_EQUAL
Rule 34    comparison_op -> GREATER_EQUAL
Rule 35    comparison_op -> EQ
Rule 36    comparison_op -> NOT_EQUAL
Rule 37    arithmetic_expr -> term
Rule 38    arithmetic_expr -> arithmetic_expr PLUS term
Rule 39    arithmetic_expr -> arithmetic_expr MINUS term
Rule 40    arithmetic_expr -> arithmetic_expr MOD term
Rule 41    term -> factor
Rule 42    term -> term MULTIPLY factor
Rule 43    term -> term DIVIDE factor
Rule 44    factor -> INTEGER
Rule 45    factor -> FLOAT
Rule 46    factor -> STRING
Rule 47    factor -> TRUE
Rule 48    factor -> FALSE
Rule 49    factor -> IDENTIFIER
Rule 50    factor -> LPAREN expression RPAREN
Rule 51    function_declaration -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
Rule 52    parameter_list -> <empty>
Rule 53    parameter_list -> type IDENTIFIER
Rule 54    parameter_list -> parameter_list COMMA type IDENTIFIER
Rule 55    function_call -> IDENTIFIER LPAREN argument_list RPAREN
Rule 56    argument_list -> <empty>
Rule 57    argument_list -> expression
Rule 58    argument_list -> argument_list COMMA expression
Rule 59    conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE
Rule 60    conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
Rule 61    loop -> WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE
Rule 62    loop -> FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE
Rule 63    for_increment -> IDENTIFIER EQUALS expression
Rule 64    for_increment -> expression
Rule 65    return_statement -> RETURN expression SEMICOLON
Rule 66    print_statement -> PRINT LPAREN expression RPAREN SEMICOLON
Rule 67    read_statement -> READ LPAREN RPAREN SEMICOLON

Terminals, with rules where they appear

AND                  : 26
BOOL_TYPE            : 21
COMMA                : 54 58
DIVIDE               : 43
ELSE                 : 60
EQ                   : 35
EQUALS               : 17 22 63
FALSE                : 48
FLOAT                : 45
FLOAT_TYPE           : 19
FOR                  : 62
FUNCTION             : 51
GREATER_EQUAL        : 34
GREATER_THAN         : 32
IDENTIFIER           : 16 17 22 49 51 53 54 55 63
IF                   : 59 60
INTEGER              : 44
INT_TYPE             : 18
LBRACE               : 51 59 60 60 61 62
LESS_EQUAL           : 33
LESS_THAN            : 31
LPAREN               : 50 51 55 59 60 61 62 66 67
MINUS                : 39
MOD                  : 40
MULTIPLY             : 42
NOT                  : 28
NOT_EQUAL            : 36
OR                   : 27
PLUS                 : 38
PRINT                : 66
RBRACE               : 51 59 60 60 61 62
READ                 : 67
RETURN               : 65
RPAREN               : 50 51 55 59 60 61 62 66 67
SEMICOLON            : 15 16 17 22 62 65 66 67
STRING               : 46
STRING_TYPE          : 20
TRUE                 : 47
WHILE                : 61
error                : 

Nonterminals, with rules where they appear

argument_list        : 55 58
arithmetic_expr      : 29 30 30 38 39 40
assignment           : 5
comparison_expr      : 25 26 27 28
comparison_op        : 30
conditional          : 8
declaration          : 4 62
empty                : 13
expression           : 17 22 50 57 58 59 60 61 62 63 64 65 66
factor               : 41 42 43
for_increment        : 62
function_call        : 15 24
function_call_statement : 7
function_declaration : 6
logical_expr         : 23 26 27
loop                 : 9
parameter_list       : 51 54
print_statement      : 11
program              : 0
read_statement       : 12
return_statement     : 10
statement            : 2 3
statement_list       : 1 3 51 59 60 60 61 62
term                 : 37 38 39 40 42 43
type                 : 16 17 53 54

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . function_declaration
    (7) statement -> . function_call_statement
    (8) statement -> . conditional
    (9) statement -> . loop
    (10) statement -> . return_statement
    (11) statement -> . print_statement
    (12) statement -> . read_statement
    (13) statement -> . empty
    (16) declaration -> . type IDENTIFIER SEMICOLON
    (17) declaration -> . type IDENTIFIER EQUALS expression SEMICOLON
    (22) assignment -> . IDENTIFIER EQUALS expression SEMICOLON
    (51) function_declaration -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (15) function_call_statement -> . function_call SEMICOLON
    (59) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE
    (60) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (61) loop -> . WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE
    (62) loop -> . FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE
    (65) return_statement -> . RETURN expression SEMICOLON
    (66) print_statement -> . PRINT LPAREN expression RPAREN SEMICOLON
    (67) read_statement -> . READ LPAREN RPAREN SEMICOLON
    (14) empty -> .
    (18) type -> . INT_TYPE
    (19) type -> . FLOAT_TYPE
    (20) type -> . STRING_TYPE
    (21) type -> . BOOL_TYPE
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for FLOAT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
    IDENTIFIER      shift and go to state 15
    FUNCTION        shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    $end            reduce using rule 14 (empty -> .)
    INT_TYPE        shift and go to state 24
    FLOAT_TYPE      shift and go to state 25
    STRING_TYPE     shift and go to state 26
    BOOL_TYPE       shift and go to state 27

  ! IDENTIFIER      [ reduce using rule 14 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 14 (empty -> .) ]
  ! IF              [ reduce using rule 14 (empty -> .) ]
  ! WHILE           [ reduce using rule 14 (empty -> .) ]
  ! FOR             [ reduce using rule 14 (empty -> .) ]
  ! RETURN          [ reduce using rule 14 (empty -> .) ]
  ! PRINT           [ reduce using rule 14 (empty -> .) ]
  ! READ            [ reduce using rule 14 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 14 (empty -> .) ]
  ! FLOAT_TYPE      [ reduce using rule 14 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 14 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 14 (empty -> .) ]

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    declaration                    shift and go to state 4
    assignment                     shift and go to state 5
    function_declaration           shift and go to state 6
    function_call_statement        shift and go to state 7
    conditional                    shift and go to state 8
    loop                           shift and go to state 9
    return_statement               shift and go to state 10
    print_statement                shift and go to state 11
    read_statement                 shift and go to state 12
    empty                          shift and go to state 13
    type                           shift and go to state 14
    function_call                  shift and go to state 17

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .
    (3) statement_list -> statement_list . statement
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . function_declaration
    (7) statement -> . function_call_statement
    (8) statement -> . conditional
    (9) statement -> . loop
    (10) statement -> . return_statement
    (11) statement -> . print_statement
    (12) statement -> . read_statement
    (13) statement -> . empty
    (16) declaration -> . type IDENTIFIER SEMICOLON
    (17) declaration -> . type IDENTIFIER EQUALS expression SEMICOLON
    (22) assignment -> . IDENTIFIER EQUALS expression SEMICOLON
    (51) function_declaration -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (15) function_call_statement -> . function_call SEMICOLON
    (59) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE
    (60) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (61) loop -> . WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE
    (62) loop -> . FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE
    (65) return_statement -> . RETURN expression SEMICOLON
    (66) print_statement -> . PRINT LPAREN expression RPAREN SEMICOLON
    (67) read_statement -> . READ LPAREN RPAREN SEMICOLON
    (14) empty -> .
    (18) type -> . INT_TYPE
    (19) type -> . FLOAT_TYPE
    (20) type -> . STRING_TYPE
    (21) type -> . BOOL_TYPE
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 1 (program -> statement_list .)
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for FLOAT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
    $end            reduce using rule 1 (program -> statement_list .)
    IDENTIFIER      shift and go to state 15
    FUNCTION        shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    INT_TYPE        shift and go to state 24
    FLOAT_TYPE      shift and go to state 25
    STRING_TYPE     shift and go to state 26
    BOOL_TYPE       shift and go to state 27

  ! IDENTIFIER      [ reduce using rule 14 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 14 (empty -> .) ]
  ! IF              [ reduce using rule 14 (empty -> .) ]
  ! WHILE           [ reduce using rule 14 (empty -> .) ]
  ! FOR             [ reduce using rule 14 (empty -> .) ]
  ! RETURN          [ reduce using rule 14 (empty -> .) ]
  ! PRINT           [ reduce using rule 14 (empty -> .) ]
  ! READ            [ reduce using rule 14 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 14 (empty -> .) ]
  ! FLOAT_TYPE      [ reduce using rule 14 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 14 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 14 (empty -> .) ]
  ! $end            [ reduce using rule 14 (empty -> .) ]

    statement                      shift and go to state 28
    declaration                    shift and go to state 4
    assignment                     shift and go to state 5
    function_declaration           shift and go to state 6
    function_call_statement        shift and go to state 7
    conditional                    shift and go to state 8
    loop                           shift and go to state 9
    return_statement               shift and go to state 10
    print_statement                shift and go to state 11
    read_statement                 shift and go to state 12
    empty                          shift and go to state 13
    type                           shift and go to state 14
    function_call                  shift and go to state 17

state 3

    (2) statement_list -> statement .

    IDENTIFIER      reduce using rule 2 (statement_list -> statement .)
    FUNCTION        reduce using rule 2 (statement_list -> statement .)
    IF              reduce using rule 2 (statement_list -> statement .)
    WHILE           reduce using rule 2 (statement_list -> statement .)
    FOR             reduce using rule 2 (statement_list -> statement .)
    RETURN          reduce using rule 2 (statement_list -> statement .)
    PRINT           reduce using rule 2 (statement_list -> statement .)
    READ            reduce using rule 2 (statement_list -> statement .)
    INT_TYPE        reduce using rule 2 (statement_list -> statement .)
    FLOAT_TYPE      reduce using rule 2 (statement_list -> statement .)
    STRING_TYPE     reduce using rule 2 (statement_list -> statement .)
    BOOL_TYPE       reduce using rule 2 (statement_list -> statement .)
    $end            reduce using rule 2 (statement_list -> statement .)
    RBRACE          reduce using rule 2 (statement_list -> statement .)


state 4

    (4) statement -> declaration .

    IDENTIFIER      reduce using rule 4 (statement -> declaration .)
    FUNCTION        reduce using rule 4 (statement -> declaration .)
    IF              reduce using rule 4 (statement -> declaration .)
    WHILE           reduce using rule 4 (statement -> declaration .)
    FOR             reduce using rule 4 (statement -> declaration .)
    RETURN          reduce using rule 4 (statement -> declaration .)
    PRINT           reduce using rule 4 (statement -> declaration .)
    READ            reduce using rule 4 (statement -> declaration .)
    INT_TYPE        reduce using rule 4 (statement -> declaration .)
    FLOAT_TYPE      reduce using rule 4 (statement -> declaration .)
    STRING_TYPE     reduce using rule 4 (statement -> declaration .)
    BOOL_TYPE       reduce using rule 4 (statement -> declaration .)
    $end            reduce using rule 4 (statement -> declaration .)
    RBRACE          reduce using rule 4 (statement -> declaration .)


state 5

    (5) statement -> assignment .

    IDENTIFIER      reduce using rule 5 (statement -> assignment .)
    FUNCTION        reduce using rule 5 (statement -> assignment .)
    IF              reduce using rule 5 (statement -> assignment .)
    WHILE           reduce using rule 5 (statement -> assignment .)
    FOR             reduce using rule 5 (statement -> assignment .)
    RETURN          reduce using rule 5 (statement -> assignment .)
    PRINT           reduce using rule 5 (statement -> assignment .)
    READ            reduce using rule 5 (statement -> assignment .)
    INT_TYPE        reduce using rule 5 (statement -> assignment .)
    FLOAT_TYPE      reduce using rule 5 (statement -> assignment .)
    STRING_TYPE     reduce using rule 5 (statement -> assignment .)
    BOOL_TYPE       reduce using rule 5 (statement -> assignment .)
    $end            reduce using rule 5 (statement -> assignment .)
    RBRACE          reduce using rule 5 (statement -> assignment .)


state 6

    (6) statement -> function_declaration .

    IDENTIFIER      reduce using rule 6 (statement -> function_declaration .)
    FUNCTION        reduce using rule 6 (statement -> function_declaration .)
    IF              reduce using rule 6 (statement -> function_declaration .)
    WHILE           reduce using rule 6 (statement -> function_declaration .)
    FOR             reduce using rule 6 (statement -> function_declaration .)
    RETURN          reduce using rule 6 (statement -> function_declaration .)
    PRINT           reduce using rule 6 (statement -> function_declaration .)
    READ            reduce using rule 6 (statement -> function_declaration .)
    INT_TYPE        reduce using rule 6 (statement -> function_declaration .)
    FLOAT_TYPE      reduce using rule 6 (statement -> function_declaration .)
    STRING_TYPE     reduce using rule 6 (statement -> function_declaration .)
    BOOL_TYPE       reduce using rule 6 (statement -> function_declaration .)
    $end            reduce using rule 6 (statement -> function_declaration .)
    RBRACE          reduce using rule 6 (statement -> function_declaration .)


state 7

    (7) statement -> function_call_statement .

    IDENTIFIER      reduce using rule 7 (statement -> function_call_statement .)
    FUNCTION        reduce using rule 7 (statement -> function_call_statement .)
    IF              reduce using rule 7 (statement -> function_call_statement .)
    WHILE           reduce using rule 7 (statement -> function_call_statement .)
    FOR             reduce using rule 7 (statement -> function_call_statement .)
    RETURN          reduce using rule 7 (statement -> function_call_statement .)
    PRINT           reduce using rule 7 (statement -> function_call_statement .)
    READ            reduce using rule 7 (statement -> function_call_statement .)
    INT_TYPE        reduce using rule 7 (statement -> function_call_statement .)
    FLOAT_TYPE      reduce using rule 7 (statement -> function_call_statement .)
    STRING_TYPE     reduce using rule 7 (statement -> function_call_statement .)
    BOOL_TYPE       reduce using rule 7 (statement -> function_call_statement .)
    $end            reduce using rule 7 (statement -> function_call_statement .)
    RBRACE          reduce using rule 7 (statement -> function_call_statement .)


state 8

    (8) statement -> conditional .

    IDENTIFIER      reduce using rule 8 (statement -> conditional .)
    FUNCTION        reduce using rule 8 (statement -> conditional .)
    IF              reduce using rule 8 (statement -> conditional .)
    WHILE           reduce using rule 8 (statement -> conditional .)
    FOR             reduce using rule 8 (statement -> conditional .)
    RETURN          reduce using rule 8 (statement -> conditional .)
    PRINT           reduce using rule 8 (statement -> conditional .)
    READ            reduce using rule 8 (statement -> conditional .)
    INT_TYPE        reduce using rule 8 (statement -> conditional .)
    FLOAT_TYPE      reduce using rule 8 (statement -> conditional .)
    STRING_TYPE     reduce using rule 8 (statement -> conditional .)
    BOOL_TYPE       reduce using rule 8 (statement -> conditional .)
    $end            reduce using rule 8 (statement -> conditional .)
    RBRACE          reduce using rule 8 (statement -> conditional .)


state 9

    (9) statement -> loop .

    IDENTIFIER      reduce using rule 9 (statement -> loop .)
    FUNCTION        reduce using rule 9 (statement -> loop .)
    IF              reduce using rule 9 (statement -> loop .)
    WHILE           reduce using rule 9 (statement -> loop .)
    FOR             reduce using rule 9 (statement -> loop .)
    RETURN          reduce using rule 9 (statement -> loop .)
    PRINT           reduce using rule 9 (statement -> loop .)
    READ            reduce using rule 9 (statement -> loop .)
    INT_TYPE        reduce using rule 9 (statement -> loop .)
    FLOAT_TYPE      reduce using rule 9 (statement -> loop .)
    STRING_TYPE     reduce using rule 9 (statement -> loop .)
    BOOL_TYPE       reduce using rule 9 (statement -> loop .)
    $end            reduce using rule 9 (statement -> loop .)
    RBRACE          reduce using rule 9 (statement -> loop .)


state 10

    (10) statement -> return_statement .

    IDENTIFIER      reduce using rule 10 (statement -> return_statement .)
    FUNCTION        reduce using rule 10 (statement -> return_statement .)
    IF              reduce using rule 10 (statement -> return_statement .)
    WHILE           reduce using rule 10 (statement -> return_statement .)
    FOR             reduce using rule 10 (statement -> return_statement .)
    RETURN          reduce using rule 10 (statement -> return_statement .)
    PRINT           reduce using rule 10 (statement -> return_statement .)
    READ            reduce using rule 10 (statement -> return_statement .)
    INT_TYPE        reduce using rule 10 (statement -> return_statement .)
    FLOAT_TYPE      reduce using rule 10 (statement -> return_statement .)
    STRING_TYPE     reduce using rule 10 (statement -> return_statement .)
    BOOL_TYPE       reduce using rule 10 (statement -> return_statement .)
    $end            reduce using rule 10 (statement -> return_statement .)
    RBRACE          reduce using rule 10 (statement -> return_statement .)


state 11

    (11) statement -> print_statement .

    IDENTIFIER      reduce using rule 11 (statement -> print_statement .)
    FUNCTION        reduce using rule 11 (statement -> print_statement .)
    IF              reduce using rule 11 (statement -> print_statement .)
    WHILE           reduce using rule 11 (statement -> print_statement .)
    FOR             reduce using rule 11 (statement -> print_statement .)
    RETURN          reduce using rule 11 (statement -> print_statement .)
    PRINT           reduce using rule 11 (statement -> print_statement .)
    READ            reduce using rule 11 (statement -> print_statement .)
    INT_TYPE        reduce using rule 11 (statement -> print_statement .)
    FLOAT_TYPE      reduce using rule 11 (statement -> print_statement .)
    STRING_TYPE     reduce using rule 11 (statement -> print_statement .)
    BOOL_TYPE       reduce using rule 11 (statement -> print_statement .)
    $end            reduce using rule 11 (statement -> print_statement .)
    RBRACE          reduce using rule 11 (statement -> print_statement .)


state 12

    (12) statement -> read_statement .

    IDENTIFIER      reduce using rule 12 (statement -> read_statement .)
    FUNCTION        reduce using rule 12 (statement -> read_statement .)
    IF              reduce using rule 12 (statement -> read_statement .)
    WHILE           reduce using rule 12 (statement -> read_statement .)
    FOR             reduce using rule 12 (statement -> read_statement .)
    RETURN          reduce using rule 12 (statement -> read_statement .)
    PRINT           reduce using rule 12 (statement -> read_statement .)
    READ            reduce using rule 12 (statement -> read_statement .)
    INT_TYPE        reduce using rule 12 (statement -> read_statement .)
    FLOAT_TYPE      reduce using rule 12 (statement -> read_statement .)
    STRING_TYPE     reduce using rule 12 (statement -> read_statement .)
    BOOL_TYPE       reduce using rule 12 (statement -> read_statement .)
    $end            reduce using rule 12 (statement -> read_statement .)
    RBRACE          reduce using rule 12 (statement -> read_statement .)


state 13

    (13) statement -> empty .

    IDENTIFIER      reduce using rule 13 (statement -> empty .)
    FUNCTION        reduce using rule 13 (statement -> empty .)
    IF              reduce using rule 13 (statement -> empty .)
    WHILE           reduce using rule 13 (statement -> empty .)
    FOR             reduce using rule 13 (statement -> empty .)
    RETURN          reduce using rule 13 (statement -> empty .)
    PRINT           reduce using rule 13 (statement -> empty .)
    READ            reduce using rule 13 (statement -> empty .)
    INT_TYPE        reduce using rule 13 (statement -> empty .)
    FLOAT_TYPE      reduce using rule 13 (statement -> empty .)
    STRING_TYPE     reduce using rule 13 (statement -> empty .)
    BOOL_TYPE       reduce using rule 13 (statement -> empty .)
    $end            reduce using rule 13 (statement -> empty .)
    RBRACE          reduce using rule 13 (statement -> empty .)


state 14

    (16) declaration -> type . IDENTIFIER SEMICOLON
    (17) declaration -> type . IDENTIFIER EQUALS expression SEMICOLON

    IDENTIFIER      shift and go to state 29


state 15

    (22) assignment -> IDENTIFIER . EQUALS expression SEMICOLON
    (55) function_call -> IDENTIFIER . LPAREN argument_list RPAREN

    EQUALS          shift and go to state 30
    LPAREN          shift and go to state 31


state 16

    (51) function_declaration -> FUNCTION . IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE

    IDENTIFIER      shift and go to state 32


state 17

    (15) function_call_statement -> function_call . SEMICOLON

    SEMICOLON       shift and go to state 33


state 18

    (59) conditional -> IF . LPAREN expression RPAREN LBRACE statement_list RBRACE
    (60) conditional -> IF . LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE

    LPAREN          shift and go to state 34


state 19

    (61) loop -> WHILE . LPAREN expression RPAREN LBRACE statement_list RBRACE

    LPAREN          shift and go to state 35


state 20

    (62) loop -> FOR . LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE

    LPAREN          shift and go to state 36


state 21

    (65) return_statement -> RETURN . expression SEMICOLON
    (23) expression -> . logical_expr
    (24) expression -> . function_call
    (25) logical_expr -> . comparison_expr
    (26) logical_expr -> . logical_expr AND comparison_expr
    (27) logical_expr -> . logical_expr OR comparison_expr
    (28) logical_expr -> . NOT comparison_expr
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (29) comparison_expr -> . arithmetic_expr
    (30) comparison_expr -> . arithmetic_expr comparison_op arithmetic_expr
    (37) arithmetic_expr -> . term
    (38) arithmetic_expr -> . arithmetic_expr PLUS term
    (39) arithmetic_expr -> . arithmetic_expr MINUS term
    (40) arithmetic_expr -> . arithmetic_expr MOD term
    (41) term -> . factor
    (42) term -> . term MULTIPLY factor
    (43) term -> . term DIVIDE factor
    (44) factor -> . INTEGER
    (45) factor -> . FLOAT
    (46) factor -> . STRING
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . IDENTIFIER
    (50) factor -> . LPAREN expression RPAREN

    NOT             shift and go to state 41
    IDENTIFIER      shift and go to state 42
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    STRING          shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LPAREN          shift and go to state 43

    expression                     shift and go to state 37
    logical_expr                   shift and go to state 38
    function_call                  shift and go to state 39
    comparison_expr                shift and go to state 40
    arithmetic_expr                shift and go to state 44
    term                           shift and go to state 45
    factor                         shift and go to state 46

state 22

    (66) print_statement -> PRINT . LPAREN expression RPAREN SEMICOLON

    LPAREN          shift and go to state 52


state 23

    (67) read_statement -> READ . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 53


state 24

    (18) type -> INT_TYPE .

    IDENTIFIER      reduce using rule 18 (type -> INT_TYPE .)


state 25

    (19) type -> FLOAT_TYPE .

    IDENTIFIER      reduce using rule 19 (type -> FLOAT_TYPE .)


state 26

    (20) type -> STRING_TYPE .

    IDENTIFIER      reduce using rule 20 (type -> STRING_TYPE .)


state 27

    (21) type -> BOOL_TYPE .

    IDENTIFIER      reduce using rule 21 (type -> BOOL_TYPE .)


state 28

    (3) statement_list -> statement_list statement .

    IDENTIFIER      reduce using rule 3 (statement_list -> statement_list statement .)
    FUNCTION        reduce using rule 3 (statement_list -> statement_list statement .)
    IF              reduce using rule 3 (statement_list -> statement_list statement .)
    WHILE           reduce using rule 3 (statement_list -> statement_list statement .)
    FOR             reduce using rule 3 (statement_list -> statement_list statement .)
    RETURN          reduce using rule 3 (statement_list -> statement_list statement .)
    PRINT           reduce using rule 3 (statement_list -> statement_list statement .)
    READ            reduce using rule 3 (statement_list -> statement_list statement .)
    INT_TYPE        reduce using rule 3 (statement_list -> statement_list statement .)
    FLOAT_TYPE      reduce using rule 3 (statement_list -> statement_list statement .)
    STRING_TYPE     reduce using rule 3 (statement_list -> statement_list statement .)
    BOOL_TYPE       reduce using rule 3 (statement_list -> statement_list statement .)
    $end            reduce using rule 3 (statement_list -> statement_list statement .)
    RBRACE          reduce using rule 3 (statement_list -> statement_list statement .)


state 29

    (16) declaration -> type IDENTIFIER . SEMICOLON
    (17) declaration -> type IDENTIFIER . EQUALS expression SEMICOLON

    SEMICOLON       shift and go to state 54
    EQUALS          shift and go to state 55


state 30

    (22) assignment -> IDENTIFIER EQUALS . expression SEMICOLON
    (23) expression -> . logical_expr
    (24) expression -> . function_call
    (25) logical_expr -> . comparison_expr
    (26) logical_expr -> . logical_expr AND comparison_expr
    (27) logical_expr -> . logical_expr OR comparison_expr
    (28) logical_expr -> . NOT comparison_expr
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (29) comparison_expr -> . arithmetic_expr
    (30) comparison_expr -> . arithmetic_expr comparison_op arithmetic_expr
    (37) arithmetic_expr -> . term
    (38) arithmetic_expr -> . arithmetic_expr PLUS term
    (39) arithmetic_expr -> . arithmetic_expr MINUS term
    (40) arithmetic_expr -> . arithmetic_expr MOD term
    (41) term -> . factor
    (42) term -> . term MULTIPLY factor
    (43) term -> . term DIVIDE factor
    (44) factor -> . INTEGER
    (45) factor -> . FLOAT
    (46) factor -> . STRING
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . IDENTIFIER
    (50) factor -> . LPAREN expression RPAREN

    NOT             shift and go to state 41
    IDENTIFIER      shift and go to state 42
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    STRING          shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LPAREN          shift and go to state 43

    expression                     shift and go to state 56
    logical_expr                   shift and go to state 38
    function_call                  shift and go to state 39
    comparison_expr                shift and go to state 40
    arithmetic_expr                shift and go to state 44
    term                           shift and go to state 45
    factor                         shift and go to state 46

state 31

    (55) function_call -> IDENTIFIER LPAREN . argument_list RPAREN
    (56) argument_list -> .
    (57) argument_list -> . expression
    (58) argument_list -> . argument_list COMMA expression
    (23) expression -> . logical_expr
    (24) expression -> . function_call
    (25) logical_expr -> . comparison_expr
    (26) logical_expr -> . logical_expr AND comparison_expr
    (27) logical_expr -> . logical_expr OR comparison_expr
    (28) logical_expr -> . NOT comparison_expr
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (29) comparison_expr -> . arithmetic_expr
    (30) comparison_expr -> . arithmetic_expr comparison_op arithmetic_expr
    (37) arithmetic_expr -> . term
    (38) arithmetic_expr -> . arithmetic_expr PLUS term
    (39) arithmetic_expr -> . arithmetic_expr MINUS term
    (40) arithmetic_expr -> . arithmetic_expr MOD term
    (41) term -> . factor
    (42) term -> . term MULTIPLY factor
    (43) term -> . term DIVIDE factor
    (44) factor -> . INTEGER
    (45) factor -> . FLOAT
    (46) factor -> . STRING
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . IDENTIFIER
    (50) factor -> . LPAREN expression RPAREN

    RPAREN          reduce using rule 56 (argument_list -> .)
    COMMA           reduce using rule 56 (argument_list -> .)
    NOT             shift and go to state 41
    IDENTIFIER      shift and go to state 42
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    STRING          shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LPAREN          shift and go to state 43

    argument_list                  shift and go to state 57
    expression                     shift and go to state 58
    logical_expr                   shift and go to state 38
    function_call                  shift and go to state 39
    comparison_expr                shift and go to state 40
    arithmetic_expr                shift and go to state 44
    term                           shift and go to state 45
    factor                         shift and go to state 46

state 32

    (51) function_declaration -> FUNCTION IDENTIFIER . LPAREN parameter_list RPAREN LBRACE statement_list RBRACE

    LPAREN          shift and go to state 59


state 33

    (15) function_call_statement -> function_call SEMICOLON .

    IDENTIFIER      reduce using rule 15 (function_call_statement -> function_call SEMICOLON .)
    FUNCTION        reduce using rule 15 (function_call_statement -> function_call SEMICOLON .)
    IF              reduce using rule 15 (function_call_statement -> function_call SEMICOLON .)
    WHILE           reduce using rule 15 (function_call_statement -> function_call SEMICOLON .)
    FOR             reduce using rule 15 (function_call_statement -> function_call SEMICOLON .)
    RETURN          reduce using rule 15 (function_call_statement -> function_call SEMICOLON .)
    PRINT           reduce using rule 15 (function_call_statement -> function_call SEMICOLON .)
    READ            reduce using rule 15 (function_call_statement -> function_call SEMICOLON .)
    INT_TYPE        reduce using rule 15 (function_call_statement -> function_call SEMICOLON .)
    FLOAT_TYPE      reduce using rule 15 (function_call_statement -> function_call SEMICOLON .)
    STRING_TYPE     reduce using rule 15 (function_call_statement -> function_call SEMICOLON .)
    BOOL_TYPE       reduce using rule 15 (function_call_statement -> function_call SEMICOLON .)
    $end            reduce using rule 15 (function_call_statement -> function_call SEMICOLON .)
    RBRACE          reduce using rule 15 (function_call_statement -> function_call SEMICOLON .)


state 34

    (59) conditional -> IF LPAREN . expression RPAREN LBRACE statement_list RBRACE
    (60) conditional -> IF LPAREN . expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (23) expression -> . logical_expr
    (24) expression -> . function_call
    (25) logical_expr -> . comparison_expr
    (26) logical_expr -> . logical_expr AND comparison_expr
    (27) logical_expr -> . logical_expr OR comparison_expr
    (28) logical_expr -> . NOT comparison_expr
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (29) comparison_expr -> . arithmetic_expr
    (30) comparison_expr -> . arithmetic_expr comparison_op arithmetic_expr
    (37) arithmetic_expr -> . term
    (38) arithmetic_expr -> . arithmetic_expr PLUS term
    (39) arithmetic_expr -> . arithmetic_expr MINUS term
    (40) arithmetic_expr -> . arithmetic_expr MOD term
    (41) term -> . factor
    (42) term -> . term MULTIPLY factor
    (43) term -> . term DIVIDE factor
    (44) factor -> . INTEGER
    (45) factor -> . FLOAT
    (46) factor -> . STRING
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . IDENTIFIER
    (50) factor -> . LPAREN expression RPAREN

    NOT             shift and go to state 41
    IDENTIFIER      shift and go to state 42
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    STRING          shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LPAREN          shift and go to state 43

    expression                     shift and go to state 60
    logical_expr                   shift and go to state 38
    function_call                  shift and go to state 39
    comparison_expr                shift and go to state 40
    arithmetic_expr                shift and go to state 44
    term                           shift and go to state 45
    factor                         shift and go to state 46

state 35

    (61) loop -> WHILE LPAREN . expression RPAREN LBRACE statement_list RBRACE
    (23) expression -> . logical_expr
    (24) expression -> . function_call
    (25) logical_expr -> . comparison_expr
    (26) logical_expr -> . logical_expr AND comparison_expr
    (27) logical_expr -> . logical_expr OR comparison_expr
    (28) logical_expr -> . NOT comparison_expr
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (29) comparison_expr -> . arithmetic_expr
    (30) comparison_expr -> . arithmetic_expr comparison_op arithmetic_expr
    (37) arithmetic_expr -> . term
    (38) arithmetic_expr -> . arithmetic_expr PLUS term
    (39) arithmetic_expr -> . arithmetic_expr MINUS term
    (40) arithmetic_expr -> . arithmetic_expr MOD term
    (41) term -> . factor
    (42) term -> . term MULTIPLY factor
    (43) term -> . term DIVIDE factor
    (44) factor -> . INTEGER
    (45) factor -> . FLOAT
    (46) factor -> . STRING
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . IDENTIFIER
    (50) factor -> . LPAREN expression RPAREN

    NOT             shift and go to state 41
    IDENTIFIER      shift and go to state 42
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    STRING          shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LPAREN          shift and go to state 43

    expression                     shift and go to state 61
    logical_expr                   shift and go to state 38
    function_call                  shift and go to state 39
    comparison_expr                shift and go to state 40
    arithmetic_expr                shift and go to state 44
    term                           shift and go to state 45
    factor                         shift and go to state 46

state 36

    (62) loop -> FOR LPAREN . declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE
    (16) declaration -> . type IDENTIFIER SEMICOLON
    (17) declaration -> . type IDENTIFIER EQUALS expression SEMICOLON
    (18) type -> . INT_TYPE
    (19) type -> . FLOAT_TYPE
    (20) type -> . STRING_TYPE
    (21) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 24
    FLOAT_TYPE      shift and go to state 25
    STRING_TYPE     shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    declaration                    shift and go to state 62
    type                           shift and go to state 14

state 37

    (65) return_statement -> RETURN expression . SEMICOLON

    SEMICOLON       shift and go to state 63


state 38

    (23) expression -> logical_expr .
    (26) logical_expr -> logical_expr . AND comparison_expr
    (27) logical_expr -> logical_expr . OR comparison_expr

    SEMICOLON       reduce using rule 23 (expression -> logical_expr .)
    RPAREN          reduce using rule 23 (expression -> logical_expr .)
    COMMA           reduce using rule 23 (expression -> logical_expr .)
    AND             shift and go to state 64
    OR              shift and go to state 65


state 39

    (24) expression -> function_call .

    SEMICOLON       reduce using rule 24 (expression -> function_call .)
    RPAREN          reduce using rule 24 (expression -> function_call .)
    COMMA           reduce using rule 24 (expression -> function_call .)


state 40

    (25) logical_expr -> comparison_expr .

    AND             reduce using rule 25 (logical_expr -> comparison_expr .)
    OR              reduce using rule 25 (logical_expr -> comparison_expr .)
    SEMICOLON       reduce using rule 25 (logical_expr -> comparison_expr .)
    RPAREN          reduce using rule 25 (logical_expr -> comparison_expr .)
    COMMA           reduce using rule 25 (logical_expr -> comparison_expr .)


state 41

    (28) logical_expr -> NOT . comparison_expr
    (29) comparison_expr -> . arithmetic_expr
    (30) comparison_expr -> . arithmetic_expr comparison_op arithmetic_expr
    (37) arithmetic_expr -> . term
    (38) arithmetic_expr -> . arithmetic_expr PLUS term
    (39) arithmetic_expr -> . arithmetic_expr MINUS term
    (40) arithmetic_expr -> . arithmetic_expr MOD term
    (41) term -> . factor
    (42) term -> . term MULTIPLY factor
    (43) term -> . term DIVIDE factor
    (44) factor -> . INTEGER
    (45) factor -> . FLOAT
    (46) factor -> . STRING
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . IDENTIFIER
    (50) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    STRING          shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDENTIFIER      shift and go to state 67
    LPAREN          shift and go to state 43

    comparison_expr                shift and go to state 66
    arithmetic_expr                shift and go to state 44
    term                           shift and go to state 45
    factor                         shift and go to state 46

state 42

    (55) function_call -> IDENTIFIER . LPAREN argument_list RPAREN
    (49) factor -> IDENTIFIER .

    LPAREN          shift and go to state 31
    MULTIPLY        reduce using rule 49 (factor -> IDENTIFIER .)
    DIVIDE          reduce using rule 49 (factor -> IDENTIFIER .)
    PLUS            reduce using rule 49 (factor -> IDENTIFIER .)
    MINUS           reduce using rule 49 (factor -> IDENTIFIER .)
    MOD             reduce using rule 49 (factor -> IDENTIFIER .)
    LESS_THAN       reduce using rule 49 (factor -> IDENTIFIER .)
    GREATER_THAN    reduce using rule 49 (factor -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 49 (factor -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 49 (factor -> IDENTIFIER .)
    EQ              reduce using rule 49 (factor -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 49 (factor -> IDENTIFIER .)
    AND             reduce using rule 49 (factor -> IDENTIFIER .)
    OR              reduce using rule 49 (factor -> IDENTIFIER .)
    SEMICOLON       reduce using rule 49 (factor -> IDENTIFIER .)
    RPAREN          reduce using rule 49 (factor -> IDENTIFIER .)
    COMMA           reduce using rule 49 (factor -> IDENTIFIER .)


state 43

    (50) factor -> LPAREN . expression RPAREN
    (23) expression -> . logical_expr
    (24) expression -> . function_call
    (25) logical_expr -> . comparison_expr
    (26) logical_expr -> . logical_expr AND comparison_expr
    (27) logical_expr -> . logical_expr OR comparison_expr
    (28) logical_expr -> . NOT comparison_expr
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (29) comparison_expr -> . arithmetic_expr
    (30) comparison_expr -> . arithmetic_expr comparison_op arithmetic_expr
    (37) arithmetic_expr -> . term
    (38) arithmetic_expr -> . arithmetic_expr PLUS term
    (39) arithmetic_expr -> . arithmetic_expr MINUS term
    (40) arithmetic_expr -> . arithmetic_expr MOD term
    (41) term -> . factor
    (42) term -> . term MULTIPLY factor
    (43) term -> . term DIVIDE factor
    (44) factor -> . INTEGER
    (45) factor -> . FLOAT
    (46) factor -> . STRING
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . IDENTIFIER
    (50) factor -> . LPAREN expression RPAREN

    NOT             shift and go to state 41
    IDENTIFIER      shift and go to state 42
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    STRING          shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LPAREN          shift and go to state 43

    expression                     shift and go to state 68
    logical_expr                   shift and go to state 38
    function_call                  shift and go to state 39
    comparison_expr                shift and go to state 40
    arithmetic_expr                shift and go to state 44
    term                           shift and go to state 45
    factor                         shift and go to state 46

state 44

    (29) comparison_expr -> arithmetic_expr .
    (30) comparison_expr -> arithmetic_expr . comparison_op arithmetic_expr
    (38) arithmetic_expr -> arithmetic_expr . PLUS term
    (39) arithmetic_expr -> arithmetic_expr . MINUS term
    (40) arithmetic_expr -> arithmetic_expr . MOD term
    (31) comparison_op -> . LESS_THAN
    (32) comparison_op -> . GREATER_THAN
    (33) comparison_op -> . LESS_EQUAL
    (34) comparison_op -> . GREATER_EQUAL
    (35) comparison_op -> . EQ
    (36) comparison_op -> . NOT_EQUAL

    AND             reduce using rule 29 (comparison_expr -> arithmetic_expr .)
    OR              reduce using rule 29 (comparison_expr -> arithmetic_expr .)
    SEMICOLON       reduce using rule 29 (comparison_expr -> arithmetic_expr .)
    RPAREN          reduce using rule 29 (comparison_expr -> arithmetic_expr .)
    COMMA           reduce using rule 29 (comparison_expr -> arithmetic_expr .)
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    MOD             shift and go to state 72
    LESS_THAN       shift and go to state 73
    GREATER_THAN    shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    EQ              shift and go to state 77
    NOT_EQUAL       shift and go to state 78

    comparison_op                  shift and go to state 69

state 45

    (37) arithmetic_expr -> term .
    (42) term -> term . MULTIPLY factor
    (43) term -> term . DIVIDE factor

    PLUS            reduce using rule 37 (arithmetic_expr -> term .)
    MINUS           reduce using rule 37 (arithmetic_expr -> term .)
    MOD             reduce using rule 37 (arithmetic_expr -> term .)
    LESS_THAN       reduce using rule 37 (arithmetic_expr -> term .)
    GREATER_THAN    reduce using rule 37 (arithmetic_expr -> term .)
    LESS_EQUAL      reduce using rule 37 (arithmetic_expr -> term .)
    GREATER_EQUAL   reduce using rule 37 (arithmetic_expr -> term .)
    EQ              reduce using rule 37 (arithmetic_expr -> term .)
    NOT_EQUAL       reduce using rule 37 (arithmetic_expr -> term .)
    AND             reduce using rule 37 (arithmetic_expr -> term .)
    OR              reduce using rule 37 (arithmetic_expr -> term .)
    SEMICOLON       reduce using rule 37 (arithmetic_expr -> term .)
    RPAREN          reduce using rule 37 (arithmetic_expr -> term .)
    COMMA           reduce using rule 37 (arithmetic_expr -> term .)
    MULTIPLY        shift and go to state 79
    DIVIDE          shift and go to state 80


state 46

    (41) term -> factor .

    MULTIPLY        reduce using rule 41 (term -> factor .)
    DIVIDE          reduce using rule 41 (term -> factor .)
    PLUS            reduce using rule 41 (term -> factor .)
    MINUS           reduce using rule 41 (term -> factor .)
    MOD             reduce using rule 41 (term -> factor .)
    LESS_THAN       reduce using rule 41 (term -> factor .)
    GREATER_THAN    reduce using rule 41 (term -> factor .)
    LESS_EQUAL      reduce using rule 41 (term -> factor .)
    GREATER_EQUAL   reduce using rule 41 (term -> factor .)
    EQ              reduce using rule 41 (term -> factor .)
    NOT_EQUAL       reduce using rule 41 (term -> factor .)
    AND             reduce using rule 41 (term -> factor .)
    OR              reduce using rule 41 (term -> factor .)
    SEMICOLON       reduce using rule 41 (term -> factor .)
    RPAREN          reduce using rule 41 (term -> factor .)
    COMMA           reduce using rule 41 (term -> factor .)


state 47

    (44) factor -> INTEGER .

    MULTIPLY        reduce using rule 44 (factor -> INTEGER .)
    DIVIDE          reduce using rule 44 (factor -> INTEGER .)
    PLUS            reduce using rule 44 (factor -> INTEGER .)
    MINUS           reduce using rule 44 (factor -> INTEGER .)
    MOD             reduce using rule 44 (factor -> INTEGER .)
    LESS_THAN       reduce using rule 44 (factor -> INTEGER .)
    GREATER_THAN    reduce using rule 44 (factor -> INTEGER .)
    LESS_EQUAL      reduce using rule 44 (factor -> INTEGER .)
    GREATER_EQUAL   reduce using rule 44 (factor -> INTEGER .)
    EQ              reduce using rule 44 (factor -> INTEGER .)
    NOT_EQUAL       reduce using rule 44 (factor -> INTEGER .)
    AND             reduce using rule 44 (factor -> INTEGER .)
    OR              reduce using rule 44 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 44 (factor -> INTEGER .)
    RPAREN          reduce using rule 44 (factor -> INTEGER .)
    COMMA           reduce using rule 44 (factor -> INTEGER .)


state 48

    (45) factor -> FLOAT .

    MULTIPLY        reduce using rule 45 (factor -> FLOAT .)
    DIVIDE          reduce using rule 45 (factor -> FLOAT .)
    PLUS            reduce using rule 45 (factor -> FLOAT .)
    MINUS           reduce using rule 45 (factor -> FLOAT .)
    MOD             reduce using rule 45 (factor -> FLOAT .)
    LESS_THAN       reduce using rule 45 (factor -> FLOAT .)
    GREATER_THAN    reduce using rule 45 (factor -> FLOAT .)
    LESS_EQUAL      reduce using rule 45 (factor -> FLOAT .)
    GREATER_EQUAL   reduce using rule 45 (factor -> FLOAT .)
    EQ              reduce using rule 45 (factor -> FLOAT .)
    NOT_EQUAL       reduce using rule 45 (factor -> FLOAT .)
    AND             reduce using rule 45 (factor -> FLOAT .)
    OR              reduce using rule 45 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 45 (factor -> FLOAT .)
    RPAREN          reduce using rule 45 (factor -> FLOAT .)
    COMMA           reduce using rule 45 (factor -> FLOAT .)


state 49

    (46) factor -> STRING .

    MULTIPLY        reduce using rule 46 (factor -> STRING .)
    DIVIDE          reduce using rule 46 (factor -> STRING .)
    PLUS            reduce using rule 46 (factor -> STRING .)
    MINUS           reduce using rule 46 (factor -> STRING .)
    MOD             reduce using rule 46 (factor -> STRING .)
    LESS_THAN       reduce using rule 46 (factor -> STRING .)
    GREATER_THAN    reduce using rule 46 (factor -> STRING .)
    LESS_EQUAL      reduce using rule 46 (factor -> STRING .)
    GREATER_EQUAL   reduce using rule 46 (factor -> STRING .)
    EQ              reduce using rule 46 (factor -> STRING .)
    NOT_EQUAL       reduce using rule 46 (factor -> STRING .)
    AND             reduce using rule 46 (factor -> STRING .)
    OR              reduce using rule 46 (factor -> STRING .)
    SEMICOLON       reduce using rule 46 (factor -> STRING .)
    RPAREN          reduce using rule 46 (factor -> STRING .)
    COMMA           reduce using rule 46 (factor -> STRING .)


state 50

    (47) factor -> TRUE .

    MULTIPLY        reduce using rule 47 (factor -> TRUE .)
    DIVIDE          reduce using rule 47 (factor -> TRUE .)
    PLUS            reduce using rule 47 (factor -> TRUE .)
    MINUS           reduce using rule 47 (factor -> TRUE .)
    MOD             reduce using rule 47 (factor -> TRUE .)
    LESS_THAN       reduce using rule 47 (factor -> TRUE .)
    GREATER_THAN    reduce using rule 47 (factor -> TRUE .)
    LESS_EQUAL      reduce using rule 47 (factor -> TRUE .)
    GREATER_EQUAL   reduce using rule 47 (factor -> TRUE .)
    EQ              reduce using rule 47 (factor -> TRUE .)
    NOT_EQUAL       reduce using rule 47 (factor -> TRUE .)
    AND             reduce using rule 47 (factor -> TRUE .)
    OR              reduce using rule 47 (factor -> TRUE .)
    SEMICOLON       reduce using rule 47 (factor -> TRUE .)
    RPAREN          reduce using rule 47 (factor -> TRUE .)
    COMMA           reduce using rule 47 (factor -> TRUE .)


state 51

    (48) factor -> FALSE .

    MULTIPLY        reduce using rule 48 (factor -> FALSE .)
    DIVIDE          reduce using rule 48 (factor -> FALSE .)
    PLUS            reduce using rule 48 (factor -> FALSE .)
    MINUS           reduce using rule 48 (factor -> FALSE .)
    MOD             reduce using rule 48 (factor -> FALSE .)
    LESS_THAN       reduce using rule 48 (factor -> FALSE .)
    GREATER_THAN    reduce using rule 48 (factor -> FALSE .)
    LESS_EQUAL      reduce using rule 48 (factor -> FALSE .)
    GREATER_EQUAL   reduce using rule 48 (factor -> FALSE .)
    EQ              reduce using rule 48 (factor -> FALSE .)
    NOT_EQUAL       reduce using rule 48 (factor -> FALSE .)
    AND             reduce using rule 48 (factor -> FALSE .)
    OR              reduce using rule 48 (factor -> FALSE .)
    SEMICOLON       reduce using rule 48 (factor -> FALSE .)
    RPAREN          reduce using rule 48 (factor -> FALSE .)
    COMMA           reduce using rule 48 (factor -> FALSE .)


state 52

    (66) print_statement -> PRINT LPAREN . expression RPAREN SEMICOLON
    (23) expression -> . logical_expr
    (24) expression -> . function_call
    (25) logical_expr -> . comparison_expr
    (26) logical_expr -> . logical_expr AND comparison_expr
    (27) logical_expr -> . logical_expr OR comparison_expr
    (28) logical_expr -> . NOT comparison_expr
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (29) comparison_expr -> . arithmetic_expr
    (30) comparison_expr -> . arithmetic_expr comparison_op arithmetic_expr
    (37) arithmetic_expr -> . term
    (38) arithmetic_expr -> . arithmetic_expr PLUS term
    (39) arithmetic_expr -> . arithmetic_expr MINUS term
    (40) arithmetic_expr -> . arithmetic_expr MOD term
    (41) term -> . factor
    (42) term -> . term MULTIPLY factor
    (43) term -> . term DIVIDE factor
    (44) factor -> . INTEGER
    (45) factor -> . FLOAT
    (46) factor -> . STRING
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . IDENTIFIER
    (50) factor -> . LPAREN expression RPAREN

    NOT             shift and go to state 41
    IDENTIFIER      shift and go to state 42
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    STRING          shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LPAREN          shift and go to state 43

    expression                     shift and go to state 81
    logical_expr                   shift and go to state 38
    function_call                  shift and go to state 39
    comparison_expr                shift and go to state 40
    arithmetic_expr                shift and go to state 44
    term                           shift and go to state 45
    factor                         shift and go to state 46

state 53

    (67) read_statement -> READ LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 82


state 54

    (16) declaration -> type IDENTIFIER SEMICOLON .

    IDENTIFIER      reduce using rule 16 (declaration -> type IDENTIFIER SEMICOLON .)
    FUNCTION        reduce using rule 16 (declaration -> type IDENTIFIER SEMICOLON .)
    IF              reduce using rule 16 (declaration -> type IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 16 (declaration -> type IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 16 (declaration -> type IDENTIFIER SEMICOLON .)
    RETURN          reduce using rule 16 (declaration -> type IDENTIFIER SEMICOLON .)
    PRINT           reduce using rule 16 (declaration -> type IDENTIFIER SEMICOLON .)
    READ            reduce using rule 16 (declaration -> type IDENTIFIER SEMICOLON .)
    INT_TYPE        reduce using rule 16 (declaration -> type IDENTIFIER SEMICOLON .)
    FLOAT_TYPE      reduce using rule 16 (declaration -> type IDENTIFIER SEMICOLON .)
    STRING_TYPE     reduce using rule 16 (declaration -> type IDENTIFIER SEMICOLON .)
    BOOL_TYPE       reduce using rule 16 (declaration -> type IDENTIFIER SEMICOLON .)
    $end            reduce using rule 16 (declaration -> type IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 16 (declaration -> type IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 16 (declaration -> type IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 16 (declaration -> type IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 16 (declaration -> type IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 16 (declaration -> type IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 16 (declaration -> type IDENTIFIER SEMICOLON .)
    LPAREN          reduce using rule 16 (declaration -> type IDENTIFIER SEMICOLON .)
    RBRACE          reduce using rule 16 (declaration -> type IDENTIFIER SEMICOLON .)


state 55

    (17) declaration -> type IDENTIFIER EQUALS . expression SEMICOLON
    (23) expression -> . logical_expr
    (24) expression -> . function_call
    (25) logical_expr -> . comparison_expr
    (26) logical_expr -> . logical_expr AND comparison_expr
    (27) logical_expr -> . logical_expr OR comparison_expr
    (28) logical_expr -> . NOT comparison_expr
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (29) comparison_expr -> . arithmetic_expr
    (30) comparison_expr -> . arithmetic_expr comparison_op arithmetic_expr
    (37) arithmetic_expr -> . term
    (38) arithmetic_expr -> . arithmetic_expr PLUS term
    (39) arithmetic_expr -> . arithmetic_expr MINUS term
    (40) arithmetic_expr -> . arithmetic_expr MOD term
    (41) term -> . factor
    (42) term -> . term MULTIPLY factor
    (43) term -> . term DIVIDE factor
    (44) factor -> . INTEGER
    (45) factor -> . FLOAT
    (46) factor -> . STRING
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . IDENTIFIER
    (50) factor -> . LPAREN expression RPAREN

    NOT             shift and go to state 41
    IDENTIFIER      shift and go to state 42
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    STRING          shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LPAREN          shift and go to state 43

    expression                     shift and go to state 83
    logical_expr                   shift and go to state 38
    function_call                  shift and go to state 39
    comparison_expr                shift and go to state 40
    arithmetic_expr                shift and go to state 44
    term                           shift and go to state 45
    factor                         shift and go to state 46

state 56

    (22) assignment -> IDENTIFIER EQUALS expression . SEMICOLON

    SEMICOLON       shift and go to state 84


state 57

    (55) function_call -> IDENTIFIER LPAREN argument_list . RPAREN
    (58) argument_list -> argument_list . COMMA expression

    RPAREN          shift and go to state 85
    COMMA           shift and go to state 86


state 58

    (57) argument_list -> expression .

    RPAREN          reduce using rule 57 (argument_list -> expression .)
    COMMA           reduce using rule 57 (argument_list -> expression .)


state 59

    (51) function_declaration -> FUNCTION IDENTIFIER LPAREN . parameter_list RPAREN LBRACE statement_list RBRACE
    (52) parameter_list -> .
    (53) parameter_list -> . type IDENTIFIER
    (54) parameter_list -> . parameter_list COMMA type IDENTIFIER
    (18) type -> . INT_TYPE
    (19) type -> . FLOAT_TYPE
    (20) type -> . STRING_TYPE
    (21) type -> . BOOL_TYPE

    RPAREN          reduce using rule 52 (parameter_list -> .)
    COMMA           reduce using rule 52 (parameter_list -> .)
    INT_TYPE        shift and go to state 24
    FLOAT_TYPE      shift and go to state 25
    STRING_TYPE     shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    parameter_list                 shift and go to state 87
    type                           shift and go to state 88

state 60

    (59) conditional -> IF LPAREN expression . RPAREN LBRACE statement_list RBRACE
    (60) conditional -> IF LPAREN expression . RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE

    RPAREN          shift and go to state 89


state 61

    (61) loop -> WHILE LPAREN expression . RPAREN LBRACE statement_list RBRACE

    RPAREN          shift and go to state 90


state 62

    (62) loop -> FOR LPAREN declaration . expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE
    (23) expression -> . logical_expr
    (24) expression -> . function_call
    (25) logical_expr -> . comparison_expr
    (26) logical_expr -> . logical_expr AND comparison_expr
    (27) logical_expr -> . logical_expr OR comparison_expr
    (28) logical_expr -> . NOT comparison_expr
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (29) comparison_expr -> . arithmetic_expr
    (30) comparison_expr -> . arithmetic_expr comparison_op arithmetic_expr
    (37) arithmetic_expr -> . term
    (38) arithmetic_expr -> . arithmetic_expr PLUS term
    (39) arithmetic_expr -> . arithmetic_expr MINUS term
    (40) arithmetic_expr -> . arithmetic_expr MOD term
    (41) term -> . factor
    (42) term -> . term MULTIPLY factor
    (43) term -> . term DIVIDE factor
    (44) factor -> . INTEGER
    (45) factor -> . FLOAT
    (46) factor -> . STRING
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . IDENTIFIER
    (50) factor -> . LPAREN expression RPAREN

    NOT             shift and go to state 41
    IDENTIFIER      shift and go to state 42
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    STRING          shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LPAREN          shift and go to state 43

    expression                     shift and go to state 91
    logical_expr                   shift and go to state 38
    function_call                  shift and go to state 39
    comparison_expr                shift and go to state 40
    arithmetic_expr                shift and go to state 44
    term                           shift and go to state 45
    factor                         shift and go to state 46

state 63

    (65) return_statement -> RETURN expression SEMICOLON .

    IDENTIFIER      reduce using rule 65 (return_statement -> RETURN expression SEMICOLON .)
    FUNCTION        reduce using rule 65 (return_statement -> RETURN expression SEMICOLON .)
    IF              reduce using rule 65 (return_statement -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 65 (return_statement -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 65 (return_statement -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 65 (return_statement -> RETURN expression SEMICOLON .)
    PRINT           reduce using rule 65 (return_statement -> RETURN expression SEMICOLON .)
    READ            reduce using rule 65 (return_statement -> RETURN expression SEMICOLON .)
    INT_TYPE        reduce using rule 65 (return_statement -> RETURN expression SEMICOLON .)
    FLOAT_TYPE      reduce using rule 65 (return_statement -> RETURN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 65 (return_statement -> RETURN expression SEMICOLON .)
    BOOL_TYPE       reduce using rule 65 (return_statement -> RETURN expression SEMICOLON .)
    $end            reduce using rule 65 (return_statement -> RETURN expression SEMICOLON .)
    RBRACE          reduce using rule 65 (return_statement -> RETURN expression SEMICOLON .)


state 64

    (26) logical_expr -> logical_expr AND . comparison_expr
    (29) comparison_expr -> . arithmetic_expr
    (30) comparison_expr -> . arithmetic_expr comparison_op arithmetic_expr
    (37) arithmetic_expr -> . term
    (38) arithmetic_expr -> . arithmetic_expr PLUS term
    (39) arithmetic_expr -> . arithmetic_expr MINUS term
    (40) arithmetic_expr -> . arithmetic_expr MOD term
    (41) term -> . factor
    (42) term -> . term MULTIPLY factor
    (43) term -> . term DIVIDE factor
    (44) factor -> . INTEGER
    (45) factor -> . FLOAT
    (46) factor -> . STRING
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . IDENTIFIER
    (50) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    STRING          shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDENTIFIER      shift and go to state 67
    LPAREN          shift and go to state 43

    comparison_expr                shift and go to state 92
    arithmetic_expr                shift and go to state 44
    term                           shift and go to state 45
    factor                         shift and go to state 46

state 65

    (27) logical_expr -> logical_expr OR . comparison_expr
    (29) comparison_expr -> . arithmetic_expr
    (30) comparison_expr -> . arithmetic_expr comparison_op arithmetic_expr
    (37) arithmetic_expr -> . term
    (38) arithmetic_expr -> . arithmetic_expr PLUS term
    (39) arithmetic_expr -> . arithmetic_expr MINUS term
    (40) arithmetic_expr -> . arithmetic_expr MOD term
    (41) term -> . factor
    (42) term -> . term MULTIPLY factor
    (43) term -> . term DIVIDE factor
    (44) factor -> . INTEGER
    (45) factor -> . FLOAT
    (46) factor -> . STRING
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . IDENTIFIER
    (50) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    STRING          shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDENTIFIER      shift and go to state 67
    LPAREN          shift and go to state 43

    comparison_expr                shift and go to state 93
    arithmetic_expr                shift and go to state 44
    term                           shift and go to state 45
    factor                         shift and go to state 46

state 66

    (28) logical_expr -> NOT comparison_expr .

    AND             reduce using rule 28 (logical_expr -> NOT comparison_expr .)
    OR              reduce using rule 28 (logical_expr -> NOT comparison_expr .)
    SEMICOLON       reduce using rule 28 (logical_expr -> NOT comparison_expr .)
    RPAREN          reduce using rule 28 (logical_expr -> NOT comparison_expr .)
    COMMA           reduce using rule 28 (logical_expr -> NOT comparison_expr .)


state 67

    (49) factor -> IDENTIFIER .

    MULTIPLY        reduce using rule 49 (factor -> IDENTIFIER .)
    DIVIDE          reduce using rule 49 (factor -> IDENTIFIER .)
    PLUS            reduce using rule 49 (factor -> IDENTIFIER .)
    MINUS           reduce using rule 49 (factor -> IDENTIFIER .)
    MOD             reduce using rule 49 (factor -> IDENTIFIER .)
    LESS_THAN       reduce using rule 49 (factor -> IDENTIFIER .)
    GREATER_THAN    reduce using rule 49 (factor -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 49 (factor -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 49 (factor -> IDENTIFIER .)
    EQ              reduce using rule 49 (factor -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 49 (factor -> IDENTIFIER .)
    AND             reduce using rule 49 (factor -> IDENTIFIER .)
    OR              reduce using rule 49 (factor -> IDENTIFIER .)
    SEMICOLON       reduce using rule 49 (factor -> IDENTIFIER .)
    RPAREN          reduce using rule 49 (factor -> IDENTIFIER .)
    COMMA           reduce using rule 49 (factor -> IDENTIFIER .)


state 68

    (50) factor -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 94


state 69

    (30) comparison_expr -> arithmetic_expr comparison_op . arithmetic_expr
    (37) arithmetic_expr -> . term
    (38) arithmetic_expr -> . arithmetic_expr PLUS term
    (39) arithmetic_expr -> . arithmetic_expr MINUS term
    (40) arithmetic_expr -> . arithmetic_expr MOD term
    (41) term -> . factor
    (42) term -> . term MULTIPLY factor
    (43) term -> . term DIVIDE factor
    (44) factor -> . INTEGER
    (45) factor -> . FLOAT
    (46) factor -> . STRING
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . IDENTIFIER
    (50) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    STRING          shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDENTIFIER      shift and go to state 67
    LPAREN          shift and go to state 43

    arithmetic_expr                shift and go to state 95
    term                           shift and go to state 45
    factor                         shift and go to state 46

state 70

    (38) arithmetic_expr -> arithmetic_expr PLUS . term
    (41) term -> . factor
    (42) term -> . term MULTIPLY factor
    (43) term -> . term DIVIDE factor
    (44) factor -> . INTEGER
    (45) factor -> . FLOAT
    (46) factor -> . STRING
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . IDENTIFIER
    (50) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    STRING          shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDENTIFIER      shift and go to state 67
    LPAREN          shift and go to state 43

    term                           shift and go to state 96
    factor                         shift and go to state 46

state 71

    (39) arithmetic_expr -> arithmetic_expr MINUS . term
    (41) term -> . factor
    (42) term -> . term MULTIPLY factor
    (43) term -> . term DIVIDE factor
    (44) factor -> . INTEGER
    (45) factor -> . FLOAT
    (46) factor -> . STRING
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . IDENTIFIER
    (50) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    STRING          shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDENTIFIER      shift and go to state 67
    LPAREN          shift and go to state 43

    term                           shift and go to state 97
    factor                         shift and go to state 46

state 72

    (40) arithmetic_expr -> arithmetic_expr MOD . term
    (41) term -> . factor
    (42) term -> . term MULTIPLY factor
    (43) term -> . term DIVIDE factor
    (44) factor -> . INTEGER
    (45) factor -> . FLOAT
    (46) factor -> . STRING
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . IDENTIFIER
    (50) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    STRING          shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDENTIFIER      shift and go to state 67
    LPAREN          shift and go to state 43

    term                           shift and go to state 98
    factor                         shift and go to state 46

state 73

    (31) comparison_op -> LESS_THAN .

    INTEGER         reduce using rule 31 (comparison_op -> LESS_THAN .)
    FLOAT           reduce using rule 31 (comparison_op -> LESS_THAN .)
    STRING          reduce using rule 31 (comparison_op -> LESS_THAN .)
    TRUE            reduce using rule 31 (comparison_op -> LESS_THAN .)
    FALSE           reduce using rule 31 (comparison_op -> LESS_THAN .)
    IDENTIFIER      reduce using rule 31 (comparison_op -> LESS_THAN .)
    LPAREN          reduce using rule 31 (comparison_op -> LESS_THAN .)


state 74

    (32) comparison_op -> GREATER_THAN .

    INTEGER         reduce using rule 32 (comparison_op -> GREATER_THAN .)
    FLOAT           reduce using rule 32 (comparison_op -> GREATER_THAN .)
    STRING          reduce using rule 32 (comparison_op -> GREATER_THAN .)
    TRUE            reduce using rule 32 (comparison_op -> GREATER_THAN .)
    FALSE           reduce using rule 32 (comparison_op -> GREATER_THAN .)
    IDENTIFIER      reduce using rule 32 (comparison_op -> GREATER_THAN .)
    LPAREN          reduce using rule 32 (comparison_op -> GREATER_THAN .)


state 75

    (33) comparison_op -> LESS_EQUAL .

    INTEGER         reduce using rule 33 (comparison_op -> LESS_EQUAL .)
    FLOAT           reduce using rule 33 (comparison_op -> LESS_EQUAL .)
    STRING          reduce using rule 33 (comparison_op -> LESS_EQUAL .)
    TRUE            reduce using rule 33 (comparison_op -> LESS_EQUAL .)
    FALSE           reduce using rule 33 (comparison_op -> LESS_EQUAL .)
    IDENTIFIER      reduce using rule 33 (comparison_op -> LESS_EQUAL .)
    LPAREN          reduce using rule 33 (comparison_op -> LESS_EQUAL .)


state 76

    (34) comparison_op -> GREATER_EQUAL .

    INTEGER         reduce using rule 34 (comparison_op -> GREATER_EQUAL .)
    FLOAT           reduce using rule 34 (comparison_op -> GREATER_EQUAL .)
    STRING          reduce using rule 34 (comparison_op -> GREATER_EQUAL .)
    TRUE            reduce using rule 34 (comparison_op -> GREATER_EQUAL .)
    FALSE           reduce using rule 34 (comparison_op -> GREATER_EQUAL .)
    IDENTIFIER      reduce using rule 34 (comparison_op -> GREATER_EQUAL .)
    LPAREN          reduce using rule 34 (comparison_op -> GREATER_EQUAL .)


state 77

    (35) comparison_op -> EQ .

    INTEGER         reduce using rule 35 (comparison_op -> EQ .)
    FLOAT           reduce using rule 35 (comparison_op -> EQ .)
    STRING          reduce using rule 35 (comparison_op -> EQ .)
    TRUE            reduce using rule 35 (comparison_op -> EQ .)
    FALSE           reduce using rule 35 (comparison_op -> EQ .)
    IDENTIFIER      reduce using rule 35 (comparison_op -> EQ .)
    LPAREN          reduce using rule 35 (comparison_op -> EQ .)


state 78

    (36) comparison_op -> NOT_EQUAL .

    INTEGER         reduce using rule 36 (comparison_op -> NOT_EQUAL .)
    FLOAT           reduce using rule 36 (comparison_op -> NOT_EQUAL .)
    STRING          reduce using rule 36 (comparison_op -> NOT_EQUAL .)
    TRUE            reduce using rule 36 (comparison_op -> NOT_EQUAL .)
    FALSE           reduce using rule 36 (comparison_op -> NOT_EQUAL .)
    IDENTIFIER      reduce using rule 36 (comparison_op -> NOT_EQUAL .)
    LPAREN          reduce using rule 36 (comparison_op -> NOT_EQUAL .)


state 79

    (42) term -> term MULTIPLY . factor
    (44) factor -> . INTEGER
    (45) factor -> . FLOAT
    (46) factor -> . STRING
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . IDENTIFIER
    (50) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    STRING          shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDENTIFIER      shift and go to state 67
    LPAREN          shift and go to state 43

    factor                         shift and go to state 99

state 80

    (43) term -> term DIVIDE . factor
    (44) factor -> . INTEGER
    (45) factor -> . FLOAT
    (46) factor -> . STRING
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . IDENTIFIER
    (50) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    STRING          shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDENTIFIER      shift and go to state 67
    LPAREN          shift and go to state 43

    factor                         shift and go to state 100

state 81

    (66) print_statement -> PRINT LPAREN expression . RPAREN SEMICOLON

    RPAREN          shift and go to state 101


state 82

    (67) read_statement -> READ LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 102


state 83

    (17) declaration -> type IDENTIFIER EQUALS expression . SEMICOLON

    SEMICOLON       shift and go to state 103


state 84

    (22) assignment -> IDENTIFIER EQUALS expression SEMICOLON .

    IDENTIFIER      reduce using rule 22 (assignment -> IDENTIFIER EQUALS expression SEMICOLON .)
    FUNCTION        reduce using rule 22 (assignment -> IDENTIFIER EQUALS expression SEMICOLON .)
    IF              reduce using rule 22 (assignment -> IDENTIFIER EQUALS expression SEMICOLON .)
    WHILE           reduce using rule 22 (assignment -> IDENTIFIER EQUALS expression SEMICOLON .)
    FOR             reduce using rule 22 (assignment -> IDENTIFIER EQUALS expression SEMICOLON .)
    RETURN          reduce using rule 22 (assignment -> IDENTIFIER EQUALS expression SEMICOLON .)
    PRINT           reduce using rule 22 (assignment -> IDENTIFIER EQUALS expression SEMICOLON .)
    READ            reduce using rule 22 (assignment -> IDENTIFIER EQUALS expression SEMICOLON .)
    INT_TYPE        reduce using rule 22 (assignment -> IDENTIFIER EQUALS expression SEMICOLON .)
    FLOAT_TYPE      reduce using rule 22 (assignment -> IDENTIFIER EQUALS expression SEMICOLON .)
    STRING_TYPE     reduce using rule 22 (assignment -> IDENTIFIER EQUALS expression SEMICOLON .)
    BOOL_TYPE       reduce using rule 22 (assignment -> IDENTIFIER EQUALS expression SEMICOLON .)
    $end            reduce using rule 22 (assignment -> IDENTIFIER EQUALS expression SEMICOLON .)
    RBRACE          reduce using rule 22 (assignment -> IDENTIFIER EQUALS expression SEMICOLON .)


state 85

    (55) function_call -> IDENTIFIER LPAREN argument_list RPAREN .

    SEMICOLON       reduce using rule 55 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 55 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    COMMA           reduce using rule 55 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)


state 86

    (58) argument_list -> argument_list COMMA . expression
    (23) expression -> . logical_expr
    (24) expression -> . function_call
    (25) logical_expr -> . comparison_expr
    (26) logical_expr -> . logical_expr AND comparison_expr
    (27) logical_expr -> . logical_expr OR comparison_expr
    (28) logical_expr -> . NOT comparison_expr
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (29) comparison_expr -> . arithmetic_expr
    (30) comparison_expr -> . arithmetic_expr comparison_op arithmetic_expr
    (37) arithmetic_expr -> . term
    (38) arithmetic_expr -> . arithmetic_expr PLUS term
    (39) arithmetic_expr -> . arithmetic_expr MINUS term
    (40) arithmetic_expr -> . arithmetic_expr MOD term
    (41) term -> . factor
    (42) term -> . term MULTIPLY factor
    (43) term -> . term DIVIDE factor
    (44) factor -> . INTEGER
    (45) factor -> . FLOAT
    (46) factor -> . STRING
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . IDENTIFIER
    (50) factor -> . LPAREN expression RPAREN

    NOT             shift and go to state 41
    IDENTIFIER      shift and go to state 42
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    STRING          shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LPAREN          shift and go to state 43

    expression                     shift and go to state 104
    logical_expr                   shift and go to state 38
    function_call                  shift and go to state 39
    comparison_expr                shift and go to state 40
    arithmetic_expr                shift and go to state 44
    term                           shift and go to state 45
    factor                         shift and go to state 46

state 87

    (51) function_declaration -> FUNCTION IDENTIFIER LPAREN parameter_list . RPAREN LBRACE statement_list RBRACE
    (54) parameter_list -> parameter_list . COMMA type IDENTIFIER

    RPAREN          shift and go to state 105
    COMMA           shift and go to state 106


state 88

    (53) parameter_list -> type . IDENTIFIER

    IDENTIFIER      shift and go to state 107


state 89

    (59) conditional -> IF LPAREN expression RPAREN . LBRACE statement_list RBRACE
    (60) conditional -> IF LPAREN expression RPAREN . LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE

    LBRACE          shift and go to state 108


state 90

    (61) loop -> WHILE LPAREN expression RPAREN . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 109


state 91

    (62) loop -> FOR LPAREN declaration expression . SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE

    SEMICOLON       shift and go to state 110


state 92

    (26) logical_expr -> logical_expr AND comparison_expr .

    AND             reduce using rule 26 (logical_expr -> logical_expr AND comparison_expr .)
    OR              reduce using rule 26 (logical_expr -> logical_expr AND comparison_expr .)
    SEMICOLON       reduce using rule 26 (logical_expr -> logical_expr AND comparison_expr .)
    RPAREN          reduce using rule 26 (logical_expr -> logical_expr AND comparison_expr .)
    COMMA           reduce using rule 26 (logical_expr -> logical_expr AND comparison_expr .)


state 93

    (27) logical_expr -> logical_expr OR comparison_expr .

    AND             reduce using rule 27 (logical_expr -> logical_expr OR comparison_expr .)
    OR              reduce using rule 27 (logical_expr -> logical_expr OR comparison_expr .)
    SEMICOLON       reduce using rule 27 (logical_expr -> logical_expr OR comparison_expr .)
    RPAREN          reduce using rule 27 (logical_expr -> logical_expr OR comparison_expr .)
    COMMA           reduce using rule 27 (logical_expr -> logical_expr OR comparison_expr .)


state 94

    (50) factor -> LPAREN expression RPAREN .

    MULTIPLY        reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    MOD             reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    LESS_THAN       reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    GREATER_THAN    reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    LESS_EQUAL      reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    GREATER_EQUAL   reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    EQ              reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    NOT_EQUAL       reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 50 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 50 (factor -> LPAREN expression RPAREN .)


state 95

    (30) comparison_expr -> arithmetic_expr comparison_op arithmetic_expr .
    (38) arithmetic_expr -> arithmetic_expr . PLUS term
    (39) arithmetic_expr -> arithmetic_expr . MINUS term
    (40) arithmetic_expr -> arithmetic_expr . MOD term

    AND             reduce using rule 30 (comparison_expr -> arithmetic_expr comparison_op arithmetic_expr .)
    OR              reduce using rule 30 (comparison_expr -> arithmetic_expr comparison_op arithmetic_expr .)
    SEMICOLON       reduce using rule 30 (comparison_expr -> arithmetic_expr comparison_op arithmetic_expr .)
    RPAREN          reduce using rule 30 (comparison_expr -> arithmetic_expr comparison_op arithmetic_expr .)
    COMMA           reduce using rule 30 (comparison_expr -> arithmetic_expr comparison_op arithmetic_expr .)
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    MOD             shift and go to state 72


state 96

    (38) arithmetic_expr -> arithmetic_expr PLUS term .
    (42) term -> term . MULTIPLY factor
    (43) term -> term . DIVIDE factor

    PLUS            reduce using rule 38 (arithmetic_expr -> arithmetic_expr PLUS term .)
    MINUS           reduce using rule 38 (arithmetic_expr -> arithmetic_expr PLUS term .)
    MOD             reduce using rule 38 (arithmetic_expr -> arithmetic_expr PLUS term .)
    LESS_THAN       reduce using rule 38 (arithmetic_expr -> arithmetic_expr PLUS term .)
    GREATER_THAN    reduce using rule 38 (arithmetic_expr -> arithmetic_expr PLUS term .)
    LESS_EQUAL      reduce using rule 38 (arithmetic_expr -> arithmetic_expr PLUS term .)
    GREATER_EQUAL   reduce using rule 38 (arithmetic_expr -> arithmetic_expr PLUS term .)
    EQ              reduce using rule 38 (arithmetic_expr -> arithmetic_expr PLUS term .)
    NOT_EQUAL       reduce using rule 38 (arithmetic_expr -> arithmetic_expr PLUS term .)
    AND             reduce using rule 38 (arithmetic_expr -> arithmetic_expr PLUS term .)
    OR              reduce using rule 38 (arithmetic_expr -> arithmetic_expr PLUS term .)
    SEMICOLON       reduce using rule 38 (arithmetic_expr -> arithmetic_expr PLUS term .)
    RPAREN          reduce using rule 38 (arithmetic_expr -> arithmetic_expr PLUS term .)
    COMMA           reduce using rule 38 (arithmetic_expr -> arithmetic_expr PLUS term .)
    MULTIPLY        shift and go to state 79
    DIVIDE          shift and go to state 80


state 97

    (39) arithmetic_expr -> arithmetic_expr MINUS term .
    (42) term -> term . MULTIPLY factor
    (43) term -> term . DIVIDE factor

    PLUS            reduce using rule 39 (arithmetic_expr -> arithmetic_expr MINUS term .)
    MINUS           reduce using rule 39 (arithmetic_expr -> arithmetic_expr MINUS term .)
    MOD             reduce using rule 39 (arithmetic_expr -> arithmetic_expr MINUS term .)
    LESS_THAN       reduce using rule 39 (arithmetic_expr -> arithmetic_expr MINUS term .)
    GREATER_THAN    reduce using rule 39 (arithmetic_expr -> arithmetic_expr MINUS term .)
    LESS_EQUAL      reduce using rule 39 (arithmetic_expr -> arithmetic_expr MINUS term .)
    GREATER_EQUAL   reduce using rule 39 (arithmetic_expr -> arithmetic_expr MINUS term .)
    EQ              reduce using rule 39 (arithmetic_expr -> arithmetic_expr MINUS term .)
    NOT_EQUAL       reduce using rule 39 (arithmetic_expr -> arithmetic_expr MINUS term .)
    AND             reduce using rule 39 (arithmetic_expr -> arithmetic_expr MINUS term .)
    OR              reduce using rule 39 (arithmetic_expr -> arithmetic_expr MINUS term .)
    SEMICOLON       reduce using rule 39 (arithmetic_expr -> arithmetic_expr MINUS term .)
    RPAREN          reduce using rule 39 (arithmetic_expr -> arithmetic_expr MINUS term .)
    COMMA           reduce using rule 39 (arithmetic_expr -> arithmetic_expr MINUS term .)
    MULTIPLY        shift and go to state 79
    DIVIDE          shift and go to state 80


state 98

    (40) arithmetic_expr -> arithmetic_expr MOD term .
    (42) term -> term . MULTIPLY factor
    (43) term -> term . DIVIDE factor

    PLUS            reduce using rule 40 (arithmetic_expr -> arithmetic_expr MOD term .)
    MINUS           reduce using rule 40 (arithmetic_expr -> arithmetic_expr MOD term .)
    MOD             reduce using rule 40 (arithmetic_expr -> arithmetic_expr MOD term .)
    LESS_THAN       reduce using rule 40 (arithmetic_expr -> arithmetic_expr MOD term .)
    GREATER_THAN    reduce using rule 40 (arithmetic_expr -> arithmetic_expr MOD term .)
    LESS_EQUAL      reduce using rule 40 (arithmetic_expr -> arithmetic_expr MOD term .)
    GREATER_EQUAL   reduce using rule 40 (arithmetic_expr -> arithmetic_expr MOD term .)
    EQ              reduce using rule 40 (arithmetic_expr -> arithmetic_expr MOD term .)
    NOT_EQUAL       reduce using rule 40 (arithmetic_expr -> arithmetic_expr MOD term .)
    AND             reduce using rule 40 (arithmetic_expr -> arithmetic_expr MOD term .)
    OR              reduce using rule 40 (arithmetic_expr -> arithmetic_expr MOD term .)
    SEMICOLON       reduce using rule 40 (arithmetic_expr -> arithmetic_expr MOD term .)
    RPAREN          reduce using rule 40 (arithmetic_expr -> arithmetic_expr MOD term .)
    COMMA           reduce using rule 40 (arithmetic_expr -> arithmetic_expr MOD term .)
    MULTIPLY        shift and go to state 79
    DIVIDE          shift and go to state 80


state 99

    (42) term -> term MULTIPLY factor .

    MULTIPLY        reduce using rule 42 (term -> term MULTIPLY factor .)
    DIVIDE          reduce using rule 42 (term -> term MULTIPLY factor .)
    PLUS            reduce using rule 42 (term -> term MULTIPLY factor .)
    MINUS           reduce using rule 42 (term -> term MULTIPLY factor .)
    MOD             reduce using rule 42 (term -> term MULTIPLY factor .)
    LESS_THAN       reduce using rule 42 (term -> term MULTIPLY factor .)
    GREATER_THAN    reduce using rule 42 (term -> term MULTIPLY factor .)
    LESS_EQUAL      reduce using rule 42 (term -> term MULTIPLY factor .)
    GREATER_EQUAL   reduce using rule 42 (term -> term MULTIPLY factor .)
    EQ              reduce using rule 42 (term -> term MULTIPLY factor .)
    NOT_EQUAL       reduce using rule 42 (term -> term MULTIPLY factor .)
    AND             reduce using rule 42 (term -> term MULTIPLY factor .)
    OR              reduce using rule 42 (term -> term MULTIPLY factor .)
    SEMICOLON       reduce using rule 42 (term -> term MULTIPLY factor .)
    RPAREN          reduce using rule 42 (term -> term MULTIPLY factor .)
    COMMA           reduce using rule 42 (term -> term MULTIPLY factor .)


state 100

    (43) term -> term DIVIDE factor .

    MULTIPLY        reduce using rule 43 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 43 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 43 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 43 (term -> term DIVIDE factor .)
    MOD             reduce using rule 43 (term -> term DIVIDE factor .)
    LESS_THAN       reduce using rule 43 (term -> term DIVIDE factor .)
    GREATER_THAN    reduce using rule 43 (term -> term DIVIDE factor .)
    LESS_EQUAL      reduce using rule 43 (term -> term DIVIDE factor .)
    GREATER_EQUAL   reduce using rule 43 (term -> term DIVIDE factor .)
    EQ              reduce using rule 43 (term -> term DIVIDE factor .)
    NOT_EQUAL       reduce using rule 43 (term -> term DIVIDE factor .)
    AND             reduce using rule 43 (term -> term DIVIDE factor .)
    OR              reduce using rule 43 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 43 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 43 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 43 (term -> term DIVIDE factor .)


state 101

    (66) print_statement -> PRINT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 111


state 102

    (67) read_statement -> READ LPAREN RPAREN SEMICOLON .

    IDENTIFIER      reduce using rule 67 (read_statement -> READ LPAREN RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 67 (read_statement -> READ LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 67 (read_statement -> READ LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 67 (read_statement -> READ LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 67 (read_statement -> READ LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 67 (read_statement -> READ LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 67 (read_statement -> READ LPAREN RPAREN SEMICOLON .)
    READ            reduce using rule 67 (read_statement -> READ LPAREN RPAREN SEMICOLON .)
    INT_TYPE        reduce using rule 67 (read_statement -> READ LPAREN RPAREN SEMICOLON .)
    FLOAT_TYPE      reduce using rule 67 (read_statement -> READ LPAREN RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 67 (read_statement -> READ LPAREN RPAREN SEMICOLON .)
    BOOL_TYPE       reduce using rule 67 (read_statement -> READ LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 67 (read_statement -> READ LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 67 (read_statement -> READ LPAREN RPAREN SEMICOLON .)


state 103

    (17) declaration -> type IDENTIFIER EQUALS expression SEMICOLON .

    IDENTIFIER      reduce using rule 17 (declaration -> type IDENTIFIER EQUALS expression SEMICOLON .)
    FUNCTION        reduce using rule 17 (declaration -> type IDENTIFIER EQUALS expression SEMICOLON .)
    IF              reduce using rule 17 (declaration -> type IDENTIFIER EQUALS expression SEMICOLON .)
    WHILE           reduce using rule 17 (declaration -> type IDENTIFIER EQUALS expression SEMICOLON .)
    FOR             reduce using rule 17 (declaration -> type IDENTIFIER EQUALS expression SEMICOLON .)
    RETURN          reduce using rule 17 (declaration -> type IDENTIFIER EQUALS expression SEMICOLON .)
    PRINT           reduce using rule 17 (declaration -> type IDENTIFIER EQUALS expression SEMICOLON .)
    READ            reduce using rule 17 (declaration -> type IDENTIFIER EQUALS expression SEMICOLON .)
    INT_TYPE        reduce using rule 17 (declaration -> type IDENTIFIER EQUALS expression SEMICOLON .)
    FLOAT_TYPE      reduce using rule 17 (declaration -> type IDENTIFIER EQUALS expression SEMICOLON .)
    STRING_TYPE     reduce using rule 17 (declaration -> type IDENTIFIER EQUALS expression SEMICOLON .)
    BOOL_TYPE       reduce using rule 17 (declaration -> type IDENTIFIER EQUALS expression SEMICOLON .)
    $end            reduce using rule 17 (declaration -> type IDENTIFIER EQUALS expression SEMICOLON .)
    NOT             reduce using rule 17 (declaration -> type IDENTIFIER EQUALS expression SEMICOLON .)
    INTEGER         reduce using rule 17 (declaration -> type IDENTIFIER EQUALS expression SEMICOLON .)
    FLOAT           reduce using rule 17 (declaration -> type IDENTIFIER EQUALS expression SEMICOLON .)
    STRING          reduce using rule 17 (declaration -> type IDENTIFIER EQUALS expression SEMICOLON .)
    TRUE            reduce using rule 17 (declaration -> type IDENTIFIER EQUALS expression SEMICOLON .)
    FALSE           reduce using rule 17 (declaration -> type IDENTIFIER EQUALS expression SEMICOLON .)
    LPAREN          reduce using rule 17 (declaration -> type IDENTIFIER EQUALS expression SEMICOLON .)
    RBRACE          reduce using rule 17 (declaration -> type IDENTIFIER EQUALS expression SEMICOLON .)


state 104

    (58) argument_list -> argument_list COMMA expression .

    RPAREN          reduce using rule 58 (argument_list -> argument_list COMMA expression .)
    COMMA           reduce using rule 58 (argument_list -> argument_list COMMA expression .)


state 105

    (51) function_declaration -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 112


state 106

    (54) parameter_list -> parameter_list COMMA . type IDENTIFIER
    (18) type -> . INT_TYPE
    (19) type -> . FLOAT_TYPE
    (20) type -> . STRING_TYPE
    (21) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 24
    FLOAT_TYPE      shift and go to state 25
    STRING_TYPE     shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    type                           shift and go to state 113

state 107

    (53) parameter_list -> type IDENTIFIER .

    RPAREN          reduce using rule 53 (parameter_list -> type IDENTIFIER .)
    COMMA           reduce using rule 53 (parameter_list -> type IDENTIFIER .)


state 108

    (59) conditional -> IF LPAREN expression RPAREN LBRACE . statement_list RBRACE
    (60) conditional -> IF LPAREN expression RPAREN LBRACE . statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . function_declaration
    (7) statement -> . function_call_statement
    (8) statement -> . conditional
    (9) statement -> . loop
    (10) statement -> . return_statement
    (11) statement -> . print_statement
    (12) statement -> . read_statement
    (13) statement -> . empty
    (16) declaration -> . type IDENTIFIER SEMICOLON
    (17) declaration -> . type IDENTIFIER EQUALS expression SEMICOLON
    (22) assignment -> . IDENTIFIER EQUALS expression SEMICOLON
    (51) function_declaration -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (15) function_call_statement -> . function_call SEMICOLON
    (59) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE
    (60) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (61) loop -> . WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE
    (62) loop -> . FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE
    (65) return_statement -> . RETURN expression SEMICOLON
    (66) print_statement -> . PRINT LPAREN expression RPAREN SEMICOLON
    (67) read_statement -> . READ LPAREN RPAREN SEMICOLON
    (14) empty -> .
    (18) type -> . INT_TYPE
    (19) type -> . FLOAT_TYPE
    (20) type -> . STRING_TYPE
    (21) type -> . BOOL_TYPE
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for FLOAT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
    IDENTIFIER      shift and go to state 15
    FUNCTION        shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RBRACE          reduce using rule 14 (empty -> .)
    INT_TYPE        shift and go to state 24
    FLOAT_TYPE      shift and go to state 25
    STRING_TYPE     shift and go to state 26
    BOOL_TYPE       shift and go to state 27

  ! IDENTIFIER      [ reduce using rule 14 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 14 (empty -> .) ]
  ! IF              [ reduce using rule 14 (empty -> .) ]
  ! WHILE           [ reduce using rule 14 (empty -> .) ]
  ! FOR             [ reduce using rule 14 (empty -> .) ]
  ! RETURN          [ reduce using rule 14 (empty -> .) ]
  ! PRINT           [ reduce using rule 14 (empty -> .) ]
  ! READ            [ reduce using rule 14 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 14 (empty -> .) ]
  ! FLOAT_TYPE      [ reduce using rule 14 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 14 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 14 (empty -> .) ]

    statement_list                 shift and go to state 114
    statement                      shift and go to state 3
    declaration                    shift and go to state 4
    assignment                     shift and go to state 5
    function_declaration           shift and go to state 6
    function_call_statement        shift and go to state 7
    conditional                    shift and go to state 8
    loop                           shift and go to state 9
    return_statement               shift and go to state 10
    print_statement                shift and go to state 11
    read_statement                 shift and go to state 12
    empty                          shift and go to state 13
    type                           shift and go to state 14
    function_call                  shift and go to state 17

state 109

    (61) loop -> WHILE LPAREN expression RPAREN LBRACE . statement_list RBRACE
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . function_declaration
    (7) statement -> . function_call_statement
    (8) statement -> . conditional
    (9) statement -> . loop
    (10) statement -> . return_statement
    (11) statement -> . print_statement
    (12) statement -> . read_statement
    (13) statement -> . empty
    (16) declaration -> . type IDENTIFIER SEMICOLON
    (17) declaration -> . type IDENTIFIER EQUALS expression SEMICOLON
    (22) assignment -> . IDENTIFIER EQUALS expression SEMICOLON
    (51) function_declaration -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (15) function_call_statement -> . function_call SEMICOLON
    (59) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE
    (60) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (61) loop -> . WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE
    (62) loop -> . FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE
    (65) return_statement -> . RETURN expression SEMICOLON
    (66) print_statement -> . PRINT LPAREN expression RPAREN SEMICOLON
    (67) read_statement -> . READ LPAREN RPAREN SEMICOLON
    (14) empty -> .
    (18) type -> . INT_TYPE
    (19) type -> . FLOAT_TYPE
    (20) type -> . STRING_TYPE
    (21) type -> . BOOL_TYPE
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for FLOAT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
    IDENTIFIER      shift and go to state 15
    FUNCTION        shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RBRACE          reduce using rule 14 (empty -> .)
    INT_TYPE        shift and go to state 24
    FLOAT_TYPE      shift and go to state 25
    STRING_TYPE     shift and go to state 26
    BOOL_TYPE       shift and go to state 27

  ! IDENTIFIER      [ reduce using rule 14 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 14 (empty -> .) ]
  ! IF              [ reduce using rule 14 (empty -> .) ]
  ! WHILE           [ reduce using rule 14 (empty -> .) ]
  ! FOR             [ reduce using rule 14 (empty -> .) ]
  ! RETURN          [ reduce using rule 14 (empty -> .) ]
  ! PRINT           [ reduce using rule 14 (empty -> .) ]
  ! READ            [ reduce using rule 14 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 14 (empty -> .) ]
  ! FLOAT_TYPE      [ reduce using rule 14 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 14 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 14 (empty -> .) ]

    statement_list                 shift and go to state 115
    statement                      shift and go to state 3
    declaration                    shift and go to state 4
    assignment                     shift and go to state 5
    function_declaration           shift and go to state 6
    function_call_statement        shift and go to state 7
    conditional                    shift and go to state 8
    loop                           shift and go to state 9
    return_statement               shift and go to state 10
    print_statement                shift and go to state 11
    read_statement                 shift and go to state 12
    empty                          shift and go to state 13
    type                           shift and go to state 14
    function_call                  shift and go to state 17

state 110

    (62) loop -> FOR LPAREN declaration expression SEMICOLON . for_increment RPAREN LBRACE statement_list RBRACE
    (63) for_increment -> . IDENTIFIER EQUALS expression
    (64) for_increment -> . expression
    (23) expression -> . logical_expr
    (24) expression -> . function_call
    (25) logical_expr -> . comparison_expr
    (26) logical_expr -> . logical_expr AND comparison_expr
    (27) logical_expr -> . logical_expr OR comparison_expr
    (28) logical_expr -> . NOT comparison_expr
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (29) comparison_expr -> . arithmetic_expr
    (30) comparison_expr -> . arithmetic_expr comparison_op arithmetic_expr
    (37) arithmetic_expr -> . term
    (38) arithmetic_expr -> . arithmetic_expr PLUS term
    (39) arithmetic_expr -> . arithmetic_expr MINUS term
    (40) arithmetic_expr -> . arithmetic_expr MOD term
    (41) term -> . factor
    (42) term -> . term MULTIPLY factor
    (43) term -> . term DIVIDE factor
    (44) factor -> . INTEGER
    (45) factor -> . FLOAT
    (46) factor -> . STRING
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . IDENTIFIER
    (50) factor -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 118
    NOT             shift and go to state 41
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    STRING          shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LPAREN          shift and go to state 43

    expression                     shift and go to state 116
    for_increment                  shift and go to state 117
    logical_expr                   shift and go to state 38
    function_call                  shift and go to state 39
    comparison_expr                shift and go to state 40
    arithmetic_expr                shift and go to state 44
    term                           shift and go to state 45
    factor                         shift and go to state 46

state 111

    (66) print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .

    IDENTIFIER      reduce using rule 66 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 66 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 66 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    WHILE           reduce using rule 66 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 66 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RETURN          reduce using rule 66 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    PRINT           reduce using rule 66 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    READ            reduce using rule 66 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    INT_TYPE        reduce using rule 66 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FLOAT_TYPE      reduce using rule 66 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 66 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    BOOL_TYPE       reduce using rule 66 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    $end            reduce using rule 66 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RBRACE          reduce using rule 66 (print_statement -> PRINT LPAREN expression RPAREN SEMICOLON .)


state 112

    (51) function_declaration -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE . statement_list RBRACE
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . function_declaration
    (7) statement -> . function_call_statement
    (8) statement -> . conditional
    (9) statement -> . loop
    (10) statement -> . return_statement
    (11) statement -> . print_statement
    (12) statement -> . read_statement
    (13) statement -> . empty
    (16) declaration -> . type IDENTIFIER SEMICOLON
    (17) declaration -> . type IDENTIFIER EQUALS expression SEMICOLON
    (22) assignment -> . IDENTIFIER EQUALS expression SEMICOLON
    (51) function_declaration -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (15) function_call_statement -> . function_call SEMICOLON
    (59) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE
    (60) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (61) loop -> . WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE
    (62) loop -> . FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE
    (65) return_statement -> . RETURN expression SEMICOLON
    (66) print_statement -> . PRINT LPAREN expression RPAREN SEMICOLON
    (67) read_statement -> . READ LPAREN RPAREN SEMICOLON
    (14) empty -> .
    (18) type -> . INT_TYPE
    (19) type -> . FLOAT_TYPE
    (20) type -> . STRING_TYPE
    (21) type -> . BOOL_TYPE
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for FLOAT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
    IDENTIFIER      shift and go to state 15
    FUNCTION        shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RBRACE          reduce using rule 14 (empty -> .)
    INT_TYPE        shift and go to state 24
    FLOAT_TYPE      shift and go to state 25
    STRING_TYPE     shift and go to state 26
    BOOL_TYPE       shift and go to state 27

  ! IDENTIFIER      [ reduce using rule 14 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 14 (empty -> .) ]
  ! IF              [ reduce using rule 14 (empty -> .) ]
  ! WHILE           [ reduce using rule 14 (empty -> .) ]
  ! FOR             [ reduce using rule 14 (empty -> .) ]
  ! RETURN          [ reduce using rule 14 (empty -> .) ]
  ! PRINT           [ reduce using rule 14 (empty -> .) ]
  ! READ            [ reduce using rule 14 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 14 (empty -> .) ]
  ! FLOAT_TYPE      [ reduce using rule 14 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 14 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 14 (empty -> .) ]

    statement_list                 shift and go to state 119
    statement                      shift and go to state 3
    declaration                    shift and go to state 4
    assignment                     shift and go to state 5
    function_declaration           shift and go to state 6
    function_call_statement        shift and go to state 7
    conditional                    shift and go to state 8
    loop                           shift and go to state 9
    return_statement               shift and go to state 10
    print_statement                shift and go to state 11
    read_statement                 shift and go to state 12
    empty                          shift and go to state 13
    type                           shift and go to state 14
    function_call                  shift and go to state 17

state 113

    (54) parameter_list -> parameter_list COMMA type . IDENTIFIER

    IDENTIFIER      shift and go to state 120


state 114

    (59) conditional -> IF LPAREN expression RPAREN LBRACE statement_list . RBRACE
    (60) conditional -> IF LPAREN expression RPAREN LBRACE statement_list . RBRACE ELSE LBRACE statement_list RBRACE
    (3) statement_list -> statement_list . statement
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . function_declaration
    (7) statement -> . function_call_statement
    (8) statement -> . conditional
    (9) statement -> . loop
    (10) statement -> . return_statement
    (11) statement -> . print_statement
    (12) statement -> . read_statement
    (13) statement -> . empty
    (16) declaration -> . type IDENTIFIER SEMICOLON
    (17) declaration -> . type IDENTIFIER EQUALS expression SEMICOLON
    (22) assignment -> . IDENTIFIER EQUALS expression SEMICOLON
    (51) function_declaration -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (15) function_call_statement -> . function_call SEMICOLON
    (59) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE
    (60) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (61) loop -> . WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE
    (62) loop -> . FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE
    (65) return_statement -> . RETURN expression SEMICOLON
    (66) print_statement -> . PRINT LPAREN expression RPAREN SEMICOLON
    (67) read_statement -> . READ LPAREN RPAREN SEMICOLON
    (14) empty -> .
    (18) type -> . INT_TYPE
    (19) type -> . FLOAT_TYPE
    (20) type -> . STRING_TYPE
    (21) type -> . BOOL_TYPE
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for FLOAT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
    RBRACE          shift and go to state 121
    IDENTIFIER      shift and go to state 15
    FUNCTION        shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    INT_TYPE        shift and go to state 24
    FLOAT_TYPE      shift and go to state 25
    STRING_TYPE     shift and go to state 26
    BOOL_TYPE       shift and go to state 27

  ! RBRACE          [ reduce using rule 14 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 14 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 14 (empty -> .) ]
  ! IF              [ reduce using rule 14 (empty -> .) ]
  ! WHILE           [ reduce using rule 14 (empty -> .) ]
  ! FOR             [ reduce using rule 14 (empty -> .) ]
  ! RETURN          [ reduce using rule 14 (empty -> .) ]
  ! PRINT           [ reduce using rule 14 (empty -> .) ]
  ! READ            [ reduce using rule 14 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 14 (empty -> .) ]
  ! FLOAT_TYPE      [ reduce using rule 14 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 14 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 14 (empty -> .) ]

    statement                      shift and go to state 28
    declaration                    shift and go to state 4
    assignment                     shift and go to state 5
    function_declaration           shift and go to state 6
    function_call_statement        shift and go to state 7
    conditional                    shift and go to state 8
    loop                           shift and go to state 9
    return_statement               shift and go to state 10
    print_statement                shift and go to state 11
    read_statement                 shift and go to state 12
    empty                          shift and go to state 13
    type                           shift and go to state 14
    function_call                  shift and go to state 17

state 115

    (61) loop -> WHILE LPAREN expression RPAREN LBRACE statement_list . RBRACE
    (3) statement_list -> statement_list . statement
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . function_declaration
    (7) statement -> . function_call_statement
    (8) statement -> . conditional
    (9) statement -> . loop
    (10) statement -> . return_statement
    (11) statement -> . print_statement
    (12) statement -> . read_statement
    (13) statement -> . empty
    (16) declaration -> . type IDENTIFIER SEMICOLON
    (17) declaration -> . type IDENTIFIER EQUALS expression SEMICOLON
    (22) assignment -> . IDENTIFIER EQUALS expression SEMICOLON
    (51) function_declaration -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (15) function_call_statement -> . function_call SEMICOLON
    (59) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE
    (60) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (61) loop -> . WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE
    (62) loop -> . FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE
    (65) return_statement -> . RETURN expression SEMICOLON
    (66) print_statement -> . PRINT LPAREN expression RPAREN SEMICOLON
    (67) read_statement -> . READ LPAREN RPAREN SEMICOLON
    (14) empty -> .
    (18) type -> . INT_TYPE
    (19) type -> . FLOAT_TYPE
    (20) type -> . STRING_TYPE
    (21) type -> . BOOL_TYPE
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for FLOAT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
    RBRACE          shift and go to state 122
    IDENTIFIER      shift and go to state 15
    FUNCTION        shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    INT_TYPE        shift and go to state 24
    FLOAT_TYPE      shift and go to state 25
    STRING_TYPE     shift and go to state 26
    BOOL_TYPE       shift and go to state 27

  ! RBRACE          [ reduce using rule 14 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 14 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 14 (empty -> .) ]
  ! IF              [ reduce using rule 14 (empty -> .) ]
  ! WHILE           [ reduce using rule 14 (empty -> .) ]
  ! FOR             [ reduce using rule 14 (empty -> .) ]
  ! RETURN          [ reduce using rule 14 (empty -> .) ]
  ! PRINT           [ reduce using rule 14 (empty -> .) ]
  ! READ            [ reduce using rule 14 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 14 (empty -> .) ]
  ! FLOAT_TYPE      [ reduce using rule 14 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 14 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 14 (empty -> .) ]

    statement                      shift and go to state 28
    declaration                    shift and go to state 4
    assignment                     shift and go to state 5
    function_declaration           shift and go to state 6
    function_call_statement        shift and go to state 7
    conditional                    shift and go to state 8
    loop                           shift and go to state 9
    return_statement               shift and go to state 10
    print_statement                shift and go to state 11
    read_statement                 shift and go to state 12
    empty                          shift and go to state 13
    type                           shift and go to state 14
    function_call                  shift and go to state 17

state 116

    (64) for_increment -> expression .

    RPAREN          reduce using rule 64 (for_increment -> expression .)


state 117

    (62) loop -> FOR LPAREN declaration expression SEMICOLON for_increment . RPAREN LBRACE statement_list RBRACE

    RPAREN          shift and go to state 123


state 118

    (63) for_increment -> IDENTIFIER . EQUALS expression
    (55) function_call -> IDENTIFIER . LPAREN argument_list RPAREN
    (49) factor -> IDENTIFIER .

    EQUALS          shift and go to state 124
    LPAREN          shift and go to state 31
    MULTIPLY        reduce using rule 49 (factor -> IDENTIFIER .)
    DIVIDE          reduce using rule 49 (factor -> IDENTIFIER .)
    PLUS            reduce using rule 49 (factor -> IDENTIFIER .)
    MINUS           reduce using rule 49 (factor -> IDENTIFIER .)
    MOD             reduce using rule 49 (factor -> IDENTIFIER .)
    LESS_THAN       reduce using rule 49 (factor -> IDENTIFIER .)
    GREATER_THAN    reduce using rule 49 (factor -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 49 (factor -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 49 (factor -> IDENTIFIER .)
    EQ              reduce using rule 49 (factor -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 49 (factor -> IDENTIFIER .)
    AND             reduce using rule 49 (factor -> IDENTIFIER .)
    OR              reduce using rule 49 (factor -> IDENTIFIER .)
    RPAREN          reduce using rule 49 (factor -> IDENTIFIER .)


state 119

    (51) function_declaration -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list . RBRACE
    (3) statement_list -> statement_list . statement
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . function_declaration
    (7) statement -> . function_call_statement
    (8) statement -> . conditional
    (9) statement -> . loop
    (10) statement -> . return_statement
    (11) statement -> . print_statement
    (12) statement -> . read_statement
    (13) statement -> . empty
    (16) declaration -> . type IDENTIFIER SEMICOLON
    (17) declaration -> . type IDENTIFIER EQUALS expression SEMICOLON
    (22) assignment -> . IDENTIFIER EQUALS expression SEMICOLON
    (51) function_declaration -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (15) function_call_statement -> . function_call SEMICOLON
    (59) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE
    (60) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (61) loop -> . WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE
    (62) loop -> . FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE
    (65) return_statement -> . RETURN expression SEMICOLON
    (66) print_statement -> . PRINT LPAREN expression RPAREN SEMICOLON
    (67) read_statement -> . READ LPAREN RPAREN SEMICOLON
    (14) empty -> .
    (18) type -> . INT_TYPE
    (19) type -> . FLOAT_TYPE
    (20) type -> . STRING_TYPE
    (21) type -> . BOOL_TYPE
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for FLOAT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
    RBRACE          shift and go to state 125
    IDENTIFIER      shift and go to state 15
    FUNCTION        shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    INT_TYPE        shift and go to state 24
    FLOAT_TYPE      shift and go to state 25
    STRING_TYPE     shift and go to state 26
    BOOL_TYPE       shift and go to state 27

  ! RBRACE          [ reduce using rule 14 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 14 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 14 (empty -> .) ]
  ! IF              [ reduce using rule 14 (empty -> .) ]
  ! WHILE           [ reduce using rule 14 (empty -> .) ]
  ! FOR             [ reduce using rule 14 (empty -> .) ]
  ! RETURN          [ reduce using rule 14 (empty -> .) ]
  ! PRINT           [ reduce using rule 14 (empty -> .) ]
  ! READ            [ reduce using rule 14 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 14 (empty -> .) ]
  ! FLOAT_TYPE      [ reduce using rule 14 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 14 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 14 (empty -> .) ]

    statement                      shift and go to state 28
    declaration                    shift and go to state 4
    assignment                     shift and go to state 5
    function_declaration           shift and go to state 6
    function_call_statement        shift and go to state 7
    conditional                    shift and go to state 8
    loop                           shift and go to state 9
    return_statement               shift and go to state 10
    print_statement                shift and go to state 11
    read_statement                 shift and go to state 12
    empty                          shift and go to state 13
    type                           shift and go to state 14
    function_call                  shift and go to state 17

state 120

    (54) parameter_list -> parameter_list COMMA type IDENTIFIER .

    RPAREN          reduce using rule 54 (parameter_list -> parameter_list COMMA type IDENTIFIER .)
    COMMA           reduce using rule 54 (parameter_list -> parameter_list COMMA type IDENTIFIER .)


state 121

    (59) conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE .
    (60) conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE . ELSE LBRACE statement_list RBRACE

    IDENTIFIER      reduce using rule 59 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    FUNCTION        reduce using rule 59 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    IF              reduce using rule 59 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 59 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    FOR             reduce using rule 59 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 59 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    PRINT           reduce using rule 59 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    READ            reduce using rule 59 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    INT_TYPE        reduce using rule 59 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    FLOAT_TYPE      reduce using rule 59 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    STRING_TYPE     reduce using rule 59 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    BOOL_TYPE       reduce using rule 59 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    $end            reduce using rule 59 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 59 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    ELSE            shift and go to state 126


state 122

    (61) loop -> WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE .

    IDENTIFIER      reduce using rule 61 (loop -> WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    FUNCTION        reduce using rule 61 (loop -> WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    IF              reduce using rule 61 (loop -> WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 61 (loop -> WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    FOR             reduce using rule 61 (loop -> WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 61 (loop -> WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    PRINT           reduce using rule 61 (loop -> WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    READ            reduce using rule 61 (loop -> WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    INT_TYPE        reduce using rule 61 (loop -> WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    FLOAT_TYPE      reduce using rule 61 (loop -> WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    STRING_TYPE     reduce using rule 61 (loop -> WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    BOOL_TYPE       reduce using rule 61 (loop -> WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    $end            reduce using rule 61 (loop -> WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 61 (loop -> WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE .)


state 123

    (62) loop -> FOR LPAREN declaration expression SEMICOLON for_increment RPAREN . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 127


state 124

    (63) for_increment -> IDENTIFIER EQUALS . expression
    (23) expression -> . logical_expr
    (24) expression -> . function_call
    (25) logical_expr -> . comparison_expr
    (26) logical_expr -> . logical_expr AND comparison_expr
    (27) logical_expr -> . logical_expr OR comparison_expr
    (28) logical_expr -> . NOT comparison_expr
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (29) comparison_expr -> . arithmetic_expr
    (30) comparison_expr -> . arithmetic_expr comparison_op arithmetic_expr
    (37) arithmetic_expr -> . term
    (38) arithmetic_expr -> . arithmetic_expr PLUS term
    (39) arithmetic_expr -> . arithmetic_expr MINUS term
    (40) arithmetic_expr -> . arithmetic_expr MOD term
    (41) term -> . factor
    (42) term -> . term MULTIPLY factor
    (43) term -> . term DIVIDE factor
    (44) factor -> . INTEGER
    (45) factor -> . FLOAT
    (46) factor -> . STRING
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . IDENTIFIER
    (50) factor -> . LPAREN expression RPAREN

    NOT             shift and go to state 41
    IDENTIFIER      shift and go to state 42
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    STRING          shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LPAREN          shift and go to state 43

    expression                     shift and go to state 128
    logical_expr                   shift and go to state 38
    function_call                  shift and go to state 39
    comparison_expr                shift and go to state 40
    arithmetic_expr                shift and go to state 44
    term                           shift and go to state 45
    factor                         shift and go to state 46

state 125

    (51) function_declaration -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .

    IDENTIFIER      reduce using rule 51 (function_declaration -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    FUNCTION        reduce using rule 51 (function_declaration -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    IF              reduce using rule 51 (function_declaration -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 51 (function_declaration -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    FOR             reduce using rule 51 (function_declaration -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 51 (function_declaration -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    PRINT           reduce using rule 51 (function_declaration -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    READ            reduce using rule 51 (function_declaration -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    INT_TYPE        reduce using rule 51 (function_declaration -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    FLOAT_TYPE      reduce using rule 51 (function_declaration -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    STRING_TYPE     reduce using rule 51 (function_declaration -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    BOOL_TYPE       reduce using rule 51 (function_declaration -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    $end            reduce using rule 51 (function_declaration -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 51 (function_declaration -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)


state 126

    (60) conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 129


state 127

    (62) loop -> FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE . statement_list RBRACE
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . function_declaration
    (7) statement -> . function_call_statement
    (8) statement -> . conditional
    (9) statement -> . loop
    (10) statement -> . return_statement
    (11) statement -> . print_statement
    (12) statement -> . read_statement
    (13) statement -> . empty
    (16) declaration -> . type IDENTIFIER SEMICOLON
    (17) declaration -> . type IDENTIFIER EQUALS expression SEMICOLON
    (22) assignment -> . IDENTIFIER EQUALS expression SEMICOLON
    (51) function_declaration -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (15) function_call_statement -> . function_call SEMICOLON
    (59) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE
    (60) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (61) loop -> . WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE
    (62) loop -> . FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE
    (65) return_statement -> . RETURN expression SEMICOLON
    (66) print_statement -> . PRINT LPAREN expression RPAREN SEMICOLON
    (67) read_statement -> . READ LPAREN RPAREN SEMICOLON
    (14) empty -> .
    (18) type -> . INT_TYPE
    (19) type -> . FLOAT_TYPE
    (20) type -> . STRING_TYPE
    (21) type -> . BOOL_TYPE
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for FLOAT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
    IDENTIFIER      shift and go to state 15
    FUNCTION        shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RBRACE          reduce using rule 14 (empty -> .)
    INT_TYPE        shift and go to state 24
    FLOAT_TYPE      shift and go to state 25
    STRING_TYPE     shift and go to state 26
    BOOL_TYPE       shift and go to state 27

  ! IDENTIFIER      [ reduce using rule 14 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 14 (empty -> .) ]
  ! IF              [ reduce using rule 14 (empty -> .) ]
  ! WHILE           [ reduce using rule 14 (empty -> .) ]
  ! FOR             [ reduce using rule 14 (empty -> .) ]
  ! RETURN          [ reduce using rule 14 (empty -> .) ]
  ! PRINT           [ reduce using rule 14 (empty -> .) ]
  ! READ            [ reduce using rule 14 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 14 (empty -> .) ]
  ! FLOAT_TYPE      [ reduce using rule 14 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 14 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 14 (empty -> .) ]

    declaration                    shift and go to state 4
    statement_list                 shift and go to state 130
    statement                      shift and go to state 3
    assignment                     shift and go to state 5
    function_declaration           shift and go to state 6
    function_call_statement        shift and go to state 7
    conditional                    shift and go to state 8
    loop                           shift and go to state 9
    return_statement               shift and go to state 10
    print_statement                shift and go to state 11
    read_statement                 shift and go to state 12
    empty                          shift and go to state 13
    type                           shift and go to state 14
    function_call                  shift and go to state 17

state 128

    (63) for_increment -> IDENTIFIER EQUALS expression .

    RPAREN          reduce using rule 63 (for_increment -> IDENTIFIER EQUALS expression .)


state 129

    (60) conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE . statement_list RBRACE
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . function_declaration
    (7) statement -> . function_call_statement
    (8) statement -> . conditional
    (9) statement -> . loop
    (10) statement -> . return_statement
    (11) statement -> . print_statement
    (12) statement -> . read_statement
    (13) statement -> . empty
    (16) declaration -> . type IDENTIFIER SEMICOLON
    (17) declaration -> . type IDENTIFIER EQUALS expression SEMICOLON
    (22) assignment -> . IDENTIFIER EQUALS expression SEMICOLON
    (51) function_declaration -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (15) function_call_statement -> . function_call SEMICOLON
    (59) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE
    (60) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (61) loop -> . WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE
    (62) loop -> . FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE
    (65) return_statement -> . RETURN expression SEMICOLON
    (66) print_statement -> . PRINT LPAREN expression RPAREN SEMICOLON
    (67) read_statement -> . READ LPAREN RPAREN SEMICOLON
    (14) empty -> .
    (18) type -> . INT_TYPE
    (19) type -> . FLOAT_TYPE
    (20) type -> . STRING_TYPE
    (21) type -> . BOOL_TYPE
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for FLOAT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
    IDENTIFIER      shift and go to state 15
    FUNCTION        shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RBRACE          reduce using rule 14 (empty -> .)
    INT_TYPE        shift and go to state 24
    FLOAT_TYPE      shift and go to state 25
    STRING_TYPE     shift and go to state 26
    BOOL_TYPE       shift and go to state 27

  ! IDENTIFIER      [ reduce using rule 14 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 14 (empty -> .) ]
  ! IF              [ reduce using rule 14 (empty -> .) ]
  ! WHILE           [ reduce using rule 14 (empty -> .) ]
  ! FOR             [ reduce using rule 14 (empty -> .) ]
  ! RETURN          [ reduce using rule 14 (empty -> .) ]
  ! PRINT           [ reduce using rule 14 (empty -> .) ]
  ! READ            [ reduce using rule 14 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 14 (empty -> .) ]
  ! FLOAT_TYPE      [ reduce using rule 14 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 14 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 14 (empty -> .) ]

    statement_list                 shift and go to state 131
    statement                      shift and go to state 3
    declaration                    shift and go to state 4
    assignment                     shift and go to state 5
    function_declaration           shift and go to state 6
    function_call_statement        shift and go to state 7
    conditional                    shift and go to state 8
    loop                           shift and go to state 9
    return_statement               shift and go to state 10
    print_statement                shift and go to state 11
    read_statement                 shift and go to state 12
    empty                          shift and go to state 13
    type                           shift and go to state 14
    function_call                  shift and go to state 17

state 130

    (62) loop -> FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list . RBRACE
    (3) statement_list -> statement_list . statement
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . function_declaration
    (7) statement -> . function_call_statement
    (8) statement -> . conditional
    (9) statement -> . loop
    (10) statement -> . return_statement
    (11) statement -> . print_statement
    (12) statement -> . read_statement
    (13) statement -> . empty
    (16) declaration -> . type IDENTIFIER SEMICOLON
    (17) declaration -> . type IDENTIFIER EQUALS expression SEMICOLON
    (22) assignment -> . IDENTIFIER EQUALS expression SEMICOLON
    (51) function_declaration -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (15) function_call_statement -> . function_call SEMICOLON
    (59) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE
    (60) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (61) loop -> . WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE
    (62) loop -> . FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE
    (65) return_statement -> . RETURN expression SEMICOLON
    (66) print_statement -> . PRINT LPAREN expression RPAREN SEMICOLON
    (67) read_statement -> . READ LPAREN RPAREN SEMICOLON
    (14) empty -> .
    (18) type -> . INT_TYPE
    (19) type -> . FLOAT_TYPE
    (20) type -> . STRING_TYPE
    (21) type -> . BOOL_TYPE
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for FLOAT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
    RBRACE          shift and go to state 132
    IDENTIFIER      shift and go to state 15
    FUNCTION        shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    INT_TYPE        shift and go to state 24
    FLOAT_TYPE      shift and go to state 25
    STRING_TYPE     shift and go to state 26
    BOOL_TYPE       shift and go to state 27

  ! RBRACE          [ reduce using rule 14 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 14 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 14 (empty -> .) ]
  ! IF              [ reduce using rule 14 (empty -> .) ]
  ! WHILE           [ reduce using rule 14 (empty -> .) ]
  ! FOR             [ reduce using rule 14 (empty -> .) ]
  ! RETURN          [ reduce using rule 14 (empty -> .) ]
  ! PRINT           [ reduce using rule 14 (empty -> .) ]
  ! READ            [ reduce using rule 14 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 14 (empty -> .) ]
  ! FLOAT_TYPE      [ reduce using rule 14 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 14 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 14 (empty -> .) ]

    declaration                    shift and go to state 4
    statement                      shift and go to state 28
    assignment                     shift and go to state 5
    function_declaration           shift and go to state 6
    function_call_statement        shift and go to state 7
    conditional                    shift and go to state 8
    loop                           shift and go to state 9
    return_statement               shift and go to state 10
    print_statement                shift and go to state 11
    read_statement                 shift and go to state 12
    empty                          shift and go to state 13
    type                           shift and go to state 14
    function_call                  shift and go to state 17

state 131

    (60) conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list . RBRACE
    (3) statement_list -> statement_list . statement
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . function_declaration
    (7) statement -> . function_call_statement
    (8) statement -> . conditional
    (9) statement -> . loop
    (10) statement -> . return_statement
    (11) statement -> . print_statement
    (12) statement -> . read_statement
    (13) statement -> . empty
    (16) declaration -> . type IDENTIFIER SEMICOLON
    (17) declaration -> . type IDENTIFIER EQUALS expression SEMICOLON
    (22) assignment -> . IDENTIFIER EQUALS expression SEMICOLON
    (51) function_declaration -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (15) function_call_statement -> . function_call SEMICOLON
    (59) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE
    (60) conditional -> . IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (61) loop -> . WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE
    (62) loop -> . FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE
    (65) return_statement -> . RETURN expression SEMICOLON
    (66) print_statement -> . PRINT LPAREN expression RPAREN SEMICOLON
    (67) read_statement -> . READ LPAREN RPAREN SEMICOLON
    (14) empty -> .
    (18) type -> . INT_TYPE
    (19) type -> . FLOAT_TYPE
    (20) type -> . STRING_TYPE
    (21) type -> . BOOL_TYPE
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for FLOAT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
    RBRACE          shift and go to state 133
    IDENTIFIER      shift and go to state 15
    FUNCTION        shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    INT_TYPE        shift and go to state 24
    FLOAT_TYPE      shift and go to state 25
    STRING_TYPE     shift and go to state 26
    BOOL_TYPE       shift and go to state 27

  ! RBRACE          [ reduce using rule 14 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 14 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 14 (empty -> .) ]
  ! IF              [ reduce using rule 14 (empty -> .) ]
  ! WHILE           [ reduce using rule 14 (empty -> .) ]
  ! FOR             [ reduce using rule 14 (empty -> .) ]
  ! RETURN          [ reduce using rule 14 (empty -> .) ]
  ! PRINT           [ reduce using rule 14 (empty -> .) ]
  ! READ            [ reduce using rule 14 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 14 (empty -> .) ]
  ! FLOAT_TYPE      [ reduce using rule 14 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 14 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 14 (empty -> .) ]

    statement                      shift and go to state 28
    declaration                    shift and go to state 4
    assignment                     shift and go to state 5
    function_declaration           shift and go to state 6
    function_call_statement        shift and go to state 7
    conditional                    shift and go to state 8
    loop                           shift and go to state 9
    return_statement               shift and go to state 10
    print_statement                shift and go to state 11
    read_statement                 shift and go to state 12
    empty                          shift and go to state 13
    type                           shift and go to state 14
    function_call                  shift and go to state 17

state 132

    (62) loop -> FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE .

    IDENTIFIER      reduce using rule 62 (loop -> FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE .)
    FUNCTION        reduce using rule 62 (loop -> FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE .)
    IF              reduce using rule 62 (loop -> FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 62 (loop -> FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE .)
    FOR             reduce using rule 62 (loop -> FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 62 (loop -> FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE .)
    PRINT           reduce using rule 62 (loop -> FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE .)
    READ            reduce using rule 62 (loop -> FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE .)
    INT_TYPE        reduce using rule 62 (loop -> FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE .)
    FLOAT_TYPE      reduce using rule 62 (loop -> FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE .)
    STRING_TYPE     reduce using rule 62 (loop -> FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE .)
    BOOL_TYPE       reduce using rule 62 (loop -> FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE .)
    $end            reduce using rule 62 (loop -> FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 62 (loop -> FOR LPAREN declaration expression SEMICOLON for_increment RPAREN LBRACE statement_list RBRACE .)


state 133

    (60) conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .

    IDENTIFIER      reduce using rule 60 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    FUNCTION        reduce using rule 60 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    IF              reduce using rule 60 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 60 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    FOR             reduce using rule 60 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 60 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    PRINT           reduce using rule 60 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    READ            reduce using rule 60 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    INT_TYPE        reduce using rule 60 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    FLOAT_TYPE      reduce using rule 60 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    STRING_TYPE     reduce using rule 60 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    BOOL_TYPE       reduce using rule 60 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    $end            reduce using rule 60 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 60 (conditional -> IF LPAREN expression RPAREN LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENTIFIER in state 0 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 0 resolved as shift
WARNING: shift/reduce conflict for READ in state 0 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 2 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 2 resolved as shift
WARNING: shift/reduce conflict for IF in state 2 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 2 resolved as shift
WARNING: shift/reduce conflict for FOR in state 2 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 2 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 2 resolved as shift
WARNING: shift/reduce conflict for READ in state 2 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 2 resolved as shift
WARNING: shift/reduce conflict for FLOAT_TYPE in state 2 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 2 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 2 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 108 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 108 resolved as shift
WARNING: shift/reduce conflict for IF in state 108 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 108 resolved as shift
WARNING: shift/reduce conflict for FOR in state 108 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 108 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 108 resolved as shift
WARNING: shift/reduce conflict for READ in state 108 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 108 resolved as shift
WARNING: shift/reduce conflict for FLOAT_TYPE in state 108 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 108 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 108 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 109 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 109 resolved as shift
WARNING: shift/reduce conflict for IF in state 109 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 109 resolved as shift
WARNING: shift/reduce conflict for FOR in state 109 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 109 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 109 resolved as shift
WARNING: shift/reduce conflict for READ in state 109 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 109 resolved as shift
WARNING: shift/reduce conflict for FLOAT_TYPE in state 109 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 109 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 109 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 112 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 112 resolved as shift
WARNING: shift/reduce conflict for IF in state 112 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 112 resolved as shift
WARNING: shift/reduce conflict for FOR in state 112 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 112 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 112 resolved as shift
WARNING: shift/reduce conflict for READ in state 112 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 112 resolved as shift
WARNING: shift/reduce conflict for FLOAT_TYPE in state 112 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 112 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 112 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 114 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 114 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 114 resolved as shift
WARNING: shift/reduce conflict for IF in state 114 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 114 resolved as shift
WARNING: shift/reduce conflict for FOR in state 114 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 114 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 114 resolved as shift
WARNING: shift/reduce conflict for READ in state 114 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 114 resolved as shift
WARNING: shift/reduce conflict for FLOAT_TYPE in state 114 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 114 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 114 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 115 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 115 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 115 resolved as shift
WARNING: shift/reduce conflict for IF in state 115 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 115 resolved as shift
WARNING: shift/reduce conflict for FOR in state 115 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 115 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 115 resolved as shift
WARNING: shift/reduce conflict for READ in state 115 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 115 resolved as shift
WARNING: shift/reduce conflict for FLOAT_TYPE in state 115 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 115 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 115 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 119 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 119 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 119 resolved as shift
WARNING: shift/reduce conflict for IF in state 119 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 119 resolved as shift
WARNING: shift/reduce conflict for FOR in state 119 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 119 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 119 resolved as shift
WARNING: shift/reduce conflict for READ in state 119 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 119 resolved as shift
WARNING: shift/reduce conflict for FLOAT_TYPE in state 119 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 119 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 119 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 127 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 127 resolved as shift
WARNING: shift/reduce conflict for IF in state 127 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 127 resolved as shift
WARNING: shift/reduce conflict for FOR in state 127 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 127 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 127 resolved as shift
WARNING: shift/reduce conflict for READ in state 127 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 127 resolved as shift
WARNING: shift/reduce conflict for FLOAT_TYPE in state 127 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 127 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 127 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 129 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 129 resolved as shift
WARNING: shift/reduce conflict for IF in state 129 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 129 resolved as shift
WARNING: shift/reduce conflict for FOR in state 129 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 129 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 129 resolved as shift
WARNING: shift/reduce conflict for READ in state 129 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 129 resolved as shift
WARNING: shift/reduce conflict for FLOAT_TYPE in state 129 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 129 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 129 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 130 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 130 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 130 resolved as shift
WARNING: shift/reduce conflict for IF in state 130 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 130 resolved as shift
WARNING: shift/reduce conflict for FOR in state 130 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 130 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 130 resolved as shift
WARNING: shift/reduce conflict for READ in state 130 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 130 resolved as shift
WARNING: shift/reduce conflict for FLOAT_TYPE in state 130 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 130 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 130 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 131 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 131 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 131 resolved as shift
WARNING: shift/reduce conflict for IF in state 131 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 131 resolved as shift
WARNING: shift/reduce conflict for FOR in state 131 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 131 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 131 resolved as shift
WARNING: shift/reduce conflict for READ in state 131 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 131 resolved as shift
WARNING: shift/reduce conflict for FLOAT_TYPE in state 131 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 131 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 131 resolved as shift
WARNING: reduce/reduce conflict in state 2 resolved using rule (program -> statement_list)
WARNING: rejected rule (empty -> <empty>) in state 2
